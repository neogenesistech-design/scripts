// ==UserScript==
// @name         Replace spectron_script.js with custom code (robust)
// @namespace    http://tampermonkey.net/
// @version      1.3
// @description  Detecta carregamentos de "spectron_script.js" e substitui o conteúdo pelo seu código. Suporta INLINE (default) ou buscar de uma URL externa via GM_xmlhttpRequest. Sempre protege a página substituindo por um stub "0" até o código final estar disponível.
// @match        https://gamesopengl.netlify.app/*
// @grant        GM_xmlhttpRequest
// @connect      *
// @run-at       document-start
// ==/UserScript==

(function () {
  'use strict';

  /////////////////////////
  // CONFIGURAÇÕES (edite aqui)
  /////////////////////////

  // modo: 'inline' ou 'url'
  const REPLACEMENT_MODE = 'url'; // 'inline' = usar REPLACEMENT_CODE; 'url' = buscar REPLACEMENT_URL

  // Se REPLACEMENT_MODE == 'inline', coloque seu código JS aqui (entre crases)
  const REPLACEMENT_CODE = `
    // --- MEU_CODIGO_AQUI ---
    console.log("✅ spectron_script.js substituído (inline)!");
    // coloque qualquer JS válido aqui
  `;

  // Se REPLACEMENT_MODE == 'url', coloque a URL que retorna o JS puro (sem wrappers)
  // Exemplo: 'https://meusite.com/meucodigo.js'
  const REPLACEMENT_URL = 'https://raw.githubusercontent.com/neogenesistech-design/scripts/refs/heads/main/vip';

  /////////////////////////
  // Implementação (não edite abaixo a menos que saiba o que faz)
  /////////////////////////

  const TARGET_NAME = 'spectron_script.js';

  // Placeholder (curto) usado imediatamente para bloquear execução do script remoto
  // Conteúdo "0" para segurança imediata
  const PLACEHOLDER_CODE = '0';
  const PLACEHOLDER_DATA_URL = 'data:text/javascript;charset=utf-8,' + encodeURIComponent(PLACEHOLDER_CODE);

  // Variáveis que serão definidas quando tivermos o código final
  let finalReplacementCode = null;        // string com código JS final
  let finalReplacementDataURL = null;     // data: URL codificada do código final

  function isTargetUrl(u) {
    try {
      return !!u && u.indexOf(TARGET_NAME) !== -1;
    } catch {
      return false;
    }
  }

  // Converte código para data URL seguro UTF-8
  function makeDataURL(code) {
    return 'data:text/javascript;charset=utf-8,' + encodeURIComponent(code);
  }

  // Define finalReplacement... a partir de uma string de código
  function setFinalReplacement(code) {
    try {
      finalReplacementCode = String(code);
      finalReplacementDataURL = makeDataURL(finalReplacementCode);
      // depois que definimos, substituímos quaisquer scripts stub por scripts com o código final
      replacePlaceholderScriptsWithFinal();
    } catch (e) {
      console.error('ReplaceScript: falha ao setar replacement code', e);
    }
  }

  // Busca código via GM_xmlhttpRequest (usado quando REPLACEMENT_MODE == 'url')
  function fetchReplacementFromUrl(url) {
    try {
      GM_xmlhttpRequest({
        method: 'GET',
        url: url,
        responseType: 'text',
        onload(response) {
          if (response && (response.status === 200 || response.status === 0)) {
            setFinalReplacement(response.responseText);
            console.log('ReplaceScript: replacement code fetched from URL.');
          } else {
            console.warn('ReplaceScript: falha ao buscar replacement code. status=', response.status);
          }
        },
        onerror(err) {
          console.error('ReplaceScript: GM_xmlhttpRequest erro', err);
        },
        ontimeout() {
          console.warn('ReplaceScript: GM_xmlhttpRequest timeout');
        }
      });
    } catch (e) {
      console.error('ReplaceScript: erro ao chamar GM_xmlhttpRequest', e);
    }
  }

  // Substitui elementos <script src="...spectron_script.js..."> existentes que foram stubbed para PLACEHOLDER_DATA_URL
  function replacePlaceholderScriptsWithFinal() {
    if (!finalReplacementDataURL && !finalReplacementCode) return;
    try {
      // localizar scripts cujo src é o placeholder
      const all = document.querySelectorAll ? document.querySelectorAll('script[src]') : [];
      for (const s of all) {
        try {
          const src = s.getAttribute('src') || s.src;
          if (src === PLACEHOLDER_DATA_URL || (finalReplacementDataURL && src === finalReplacementDataURL)) {
            // Criar novo script inline com o código final — isso preserva atributos (tipo, async, defer, etc.)
            const newScript = document.createElement('script');
            // copia atributos exceto src
            if (s.hasAttributes && s.hasAttributes()) {
              for (const attr of Array.from(s.attributes)) {
                if (attr.name.toLowerCase() === 'src') continue;
                newScript.setAttribute(attr.name, attr.value);
              }
            }
            // colocar o código final como texto (não como data URL) — é mais robusto
            newScript.textContent = finalReplacementCode || '';
            s.parentNode && s.parentNode.replaceChild(newScript, s);
          }
        } catch (inner) { /* ignore */ }
      }
    } catch (e) {
      console.error('ReplaceScript: erro ao substituir placeholder scripts', e);
    }
  }

  // Inicializa finalReplacement quando em modo inline
  if (REPLACEMENT_MODE === 'inline') {
    setFinalReplacement(REPLACEMENT_CODE);
  } else if (REPLACEMENT_MODE === 'url') {
    // define um stub (placeholder) imediatamente e inicia a busca assíncrona
    // o stub é usado para bloquear o script original até que tenhamos o real
    fetchReplacementFromUrl(REPLACEMENT_URL);
  } else {
    console.warn('ReplaceScript: REPLACEMENT_MODE inválido. Usando inline por segurança.');
    setFinalReplacement(REPLACEMENT_CODE);
  }

  // OBSERVADOR: substitui scripts adicionados dinamicamente (subtree)
  const mo = new MutationObserver((mutations) => {
    for (const m of mutations) {
      for (const node of m.addedNodes) {
        try {
          if (node.nodeType !== 1) continue;
          if (node.tagName === 'SCRIPT') {
            const s = node.getAttribute('src') || node.src;
            if (isTargetUrl(s)) {
              // se já temos finalReplacementDataURL disponível, use-a; senão use PLACEHOLDER_DATA_URL
              const use = finalReplacementDataURL || PLACEHOLDER_DATA_URL;
              // definir src de forma segura
              try { node.setAttribute('src', use); } catch { node.src = use; }
              // se já temos o código final (finalReplacementCode), substituir imediatamente por um script inline
              if (finalReplacementCode) {
                const inline = document.createElement('script');
                // copia atributos
                if (node.hasAttributes && node.hasAttributes()) {
                  for (const attr of Array.from(node.attributes)) {
                    if (attr.name.toLowerCase() === 'src') continue;
                    inline.setAttribute(attr.name, attr.value);
                  }
                }
                inline.textContent = finalReplacementCode;
                node.parentNode && node.parentNode.replaceChild(inline, node);
              }
            }
          } else {
            // se um subtree/container foi adicionado, verificar scripts dentro
            const scripts = node.querySelectorAll && node.querySelectorAll('script[src]');
            if (scripts && scripts.length) {
              for (const s of scripts) {
                try {
                  const src = s.getAttribute('src') || s.src;
                  if (isTargetUrl(src)) {
                    const use = finalReplacementDataURL || PLACEHOLDER_DATA_URL;
                    s.setAttribute('src', use);
                    if (finalReplacementCode) {
                      const inline = document.createElement('script');
                      if (s.hasAttributes && s.hasAttributes()) {
                        for (const attr of Array.from(s.attributes)) {
                          if (attr.name.toLowerCase() === 'src') continue;
                          inline.setAttribute(attr.name, attr.value);
                        }
                      }
                      inline.textContent = finalReplacementCode;
                      s.parentNode && s.parentNode.replaceChild(inline, s);
                    }
                  }
                } catch (inner) { /* ignore */ }
              }
            }
          }
        } catch (e) { /* ignore */ }
      }
    }
  });

  try {
    mo.observe(document.documentElement || document, { childList: true, subtree: true });
  } catch (e) { /* ignore */ }

  // Intercepta document.createElement para capturar atribuições src em scripts
  const origCreate = Document.prototype.createElement;
  Document.prototype.createElement = function (tagName, options) {
    const el = origCreate.call(this, tagName, options);
    try {
      if (String(tagName).toLowerCase() === 'script') {
        const origSetAttr = el.setAttribute;
        el.setAttribute = function (name, value) {
          try {
            if (String(name).toLowerCase() === 'src' && isTargetUrl(value)) {
              // se já tivermos replacement final disponível, use-o; caso contrário use o placeholder
              const use = finalReplacementDataURL || PLACEHOLDER_DATA_URL;
              return origSetAttr.call(this, 'src', use);
            }
          } catch (e) { /* ignore */ }
          return origSetAttr.call(this, name, value);
        };

        // define propriedade 'src' para capturar atribuições diretas el.src = ...
        try {
          Object.defineProperty(el, 'src', {
            set(v) {
              try {
                if (isTargetUrl(v)) {
                  const use = finalReplacementDataURL || PLACEHOLDER_DATA_URL;
                  HTMLElement.prototype.setAttribute.call(this, 'src', use);
                  return;
                }
              } catch (e) { /* ignore */ }
              HTMLElement.prototype.setAttribute.call(this, 'src', v);
            },
            get() {
              return HTMLElement.prototype.getAttribute.call(this, 'src');
            },
            configurable: true,
            enumerable: true
          });
        } catch (e) { /* alguns ambientes bloqueiam defineProperty em instâncias */ }
      }
    } catch (e) { /* ignore */ }
    return el;
  };

  // Função de wrap para appendChild / insertBefore / replaceChild — com tratamento seguro de argumentos
  const wrapMethod = (proto, methodName, minArgs) => {
    const orig = proto[methodName];
    proto[methodName] = function (...args) {
      try {
        const node = args[0];
        if (node && node.tagName === 'SCRIPT') {
          const s = node.getAttribute('src') || node.src;
          if (isTargetUrl(s)) {
            // se já temos replacement final, preferir inline (se disponível)
            if (finalReplacementCode) {
              const inline = document.createElement('script');
              if (node.hasAttributes && node.hasAttributes()) {
                for (const attr of Array.from(node.attributes)) {
                  if (attr.name.toLowerCase() === 'src') continue;
                  inline.setAttribute(attr.name, attr.value);
                }
              }
              inline.textContent = finalReplacementCode;
              // substituir args[0] por inline node
              args[0] = inline;
            } else {
              // senão, mude o src para placeholder/partial data url
              const use = finalReplacementDataURL || PLACEHOLDER_DATA_URL;
              try { node.setAttribute('src', use); } catch { node.src = use; }
            }
          }
        }
      } catch (e) { /* ignore */ }

      // alguns códigos chamam insertBefore com 1 argumento (inapropriado) — garantir que o número mínimo de args exista
      if (args.length < minArgs) {
        // para insertBefore, o segundo argumento pode ser null — é aceitável
        while (args.length < minArgs) args.push(null);
      }
      return orig.apply(this, args);
    };
  };

  wrapMethod(Node.prototype, 'appendChild', 1);
  wrapMethod(Node.prototype, 'insertBefore', 2);
  wrapMethod(Node.prototype, 'replaceChild', 2);

  // Substitui scripts já presentes no documento (início)
  try {
    const existing = document.querySelectorAll ? document.querySelectorAll('script[src]') : [];
    for (const s of existing) {
      try {
        const src = s.getAttribute('src') || s.src;
        if (isTargetUrl(src)) {
          // se já tivermos final replacement, injetar inline; senão usar placeholder
          if (finalReplacementCode) {
            const inline = document.createElement('script');
            if (s.hasAttributes && s.hasAttributes()) {
              for (const attr of Array.from(s.attributes)) {
                if (attr.name.toLowerCase() === 'src') continue;
                inline.setAttribute(attr.name, attr.value);
              }
            }
            inline.textContent = finalReplacementCode;
            s.parentNode && s.parentNode.replaceChild(inline, s);
          } else {
            s.setAttribute('src', PLACEHOLDER_DATA_URL);
          }
        }
      } catch (inner) { /* ignore */ }
    }
  } catch (e) { /* ignore */ }

  // Intercepta document.write (caso páginas injetem tags via document.write)
  try {
    const origWrite = document.write;
    document.write = function (...args) {
      try {
        const out = args.map(a => String(a).replace(new RegExp(TARGET_NAME, 'g'), PLACEHOLDER_DATA_URL));
        return origWrite.apply(this, out);
      } catch (e) {
        return origWrite.apply(this, args);
      }
    };
  } catch (e) { /* ignore */ }

  // Se o modo era 'url' e já terminou a requisição antes dos intercepts, replacePlaceholderScriptsWithFinal() cuidará de trocar.
  // Se a requisição ainda acontecer depois, o handler onload de GM_xmlhttpRequest chamará setFinalReplacement e forçará a substituição.
})();
