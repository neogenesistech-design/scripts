setTimeout(() => {
    // Função malloc para alocar memória em código nativo (libc)
    var malloc = getFunc("libc.so", "malloc", "pointer", ["int"])

    // Variável para gerenciar toasts e evitar sobreposição
    let currentToast = null;

    // Função que carrega classes Android necessárias
    function getClassLoader() {
        const classLoader = {
            Gravity: Java.use("android.view.Gravity"),
            TextView: Java.use("android.widget.TextView"),
            LinearLayout: Java.use("android.widget.LinearLayout"),
            ViewGroup_LayoutParams: Java.use("android.view.ViewGroup$LayoutParams"),
            LinearLayout_LayoutParams: Java.use("android.widget.LinearLayout$LayoutParams"),
            Color: Java.use("android.graphics.Color"),
            ActivityThread: Java.use("android.app.ActivityThread"),
            ActivityThread_ActivityClientRecord: Java.use("android.app.ActivityThread$ActivityClientRecord"),
            View_OnTouchListener: Java.use("android.view.View$OnTouchListener"),
            MotionEvent: Java.use("android.view.MotionEvent"),
            String: Java.use("java.lang.String"),
            ScrollView: Java.use("android.widget.ScrollView"),
            View_OnClickListener: Java.use("android.view.View$OnClickListener"),
            SeekBar: Java.use("android.widget.SeekBar"),
            ClipboardManager: Java.use("android.content.ClipboardManager"),
            ClipData: Java.use("android.content.ClipData")
        }
        return classLoader
    }

    // Função que converte dp para pixels
    function pixelDensityToPixels(context, dp) {
        const density = context.getResources().getDisplayMetrics().density.value
        return parseInt(dp * density)
    }

    // Função para obter a Activity principal
    function getMainActivity(classLoader) {
        const activityThread = classLoader.ActivityThread.sCurrentActivityThread.value
        const mActivities = activityThread.mActivities.value
        const activityClientRecord = Java.cast(mActivities.valueAt(0), classLoader.ActivityThread_ActivityClientRecord)
        return activityClientRecord.activity.value
    }

    // Função para exibir um Toast
    function showToast(text, time = 1) {
        Java.perform(() => {
            Java.scheduleOnMainThread(function() {
                if (currentToast) {
                    currentToast.cancel();
                }
                var toast = Java.use("android.widget.Toast");
                var newToast = toast.makeText(Java.use("android.app.ActivityThread").currentApplication().getApplicationContext(),
                    Java.use("java.lang.String").$new(text), time);
                newToast.show();
                currentToast = newToast;
            });
        });
    }

    // Classe Menu (com modificações para o Function Tracer)
    class Menu {
        #classLoader; #activity; #MATCH_PARENT; #WRAP_CONTENT; #contentView; #mainLayout; #menuStart; #menuLayout; #menuBarLayout; #menuBarTitle; #options; #colorOn; #colorOff;
        #panelsContainerLayout; #leftPanelLayout; #rightPanelLayout; #menuScrollView; #menuScrollLayout; #tracerScrollView; #tracerListLayout;

        constructor(classLoader, activity) {
            this.#classLoader = classLoader
            this.#activity = activity
            this.#MATCH_PARENT = classLoader.LinearLayout_LayoutParams.MATCH_PARENT.value
            this.#WRAP_CONTENT = classLoader.LinearLayout_LayoutParams.WRAP_CONTENT.value
            this.#options = {}
            this.#createContentView()
            this.#createMainLayout()
        }

        #createContentView() {
            this.#contentView = this.#classLoader.LinearLayout.$new(this.#activity)
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#MATCH_PARENT)
            this.#contentView.setLayoutParams(layoutParams)
            this.#contentView.setGravity(this.#classLoader.Gravity.CENTER.value)
            this.#contentView.setBackgroundColor(this.#classLoader.Color.TRANSPARENT.value)
        }

        #createMainLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
            this.#mainLayout = this.#classLoader.LinearLayout.$new(this.#activity)
            this.#mainLayout.setLayoutParams(layoutParams)
        }

        createMenuLayout(color, width, height) {
            const widthPx = pixelDensityToPixels(this.#activity, width);
            const heightPx = pixelDensityToPixels(this.#activity, height);
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(widthPx, heightPx);
            this.#menuLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#menuLayout.setLayoutParams(layoutParams);
            this.#menuLayout.setBackgroundColor(this.#classLoader.Color.parseColor(color));
            this.#menuLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
        }

        createMenuBarLayout(color) {
            const padding = pixelDensityToPixels(this.#activity, 10)
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT)
            this.#menuBarLayout = this.#classLoader.LinearLayout.$new(this.#activity)
            this.#menuBarLayout.setLayoutParams(layoutParams)
            this.#menuBarLayout.setBackgroundColor(this.#classLoader.Color.parseColor(color))
            this.#menuBarLayout.setPadding(padding, padding, 0, padding)
        }

        createMenuBarTitle(title, color) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
            this.#menuBarTitle = this.#classLoader.TextView.$new(this.#activity)
            this.#menuBarTitle.setLayoutParams(layoutParams)
            this.#menuBarTitle.setText(this.#classLoader.String.$new(title))
            this.#menuBarTitle.setTextColor(this.#classLoader.Color.parseColor(color))
        }

        #createPanelsContainerLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#MATCH_PARENT);
            this.#panelsContainerLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#panelsContainerLayout.setLayoutParams(layoutParams);
            this.#panelsContainerLayout.setOrientation(this.#classLoader.LinearLayout.HORIZONTAL.value);
        }

        #createLeftPanelLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(0, this.#MATCH_PARENT, 1.0);
            this.#leftPanelLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#leftPanelLayout.setLayoutParams(layoutParams);
            this.#leftPanelLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
        }

        #createRightPanelLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(0, this.#MATCH_PARENT, 1.5);
            const padding = pixelDensityToPixels(this.#activity, 8);
            this.#rightPanelLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#rightPanelLayout.setLayoutParams(layoutParams);
            this.#rightPanelLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
            this.#rightPanelLayout.setPadding(padding, padding, padding, padding);

            this.#tracerScrollView = this.#classLoader.ScrollView.$new(this.#activity);
            this.#tracerListLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#tracerListLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);

            const infoTitle = this.#classLoader.TextView.$new(this.#activity);
            infoTitle.setText(this.#classLoader.String.$new("--- Function Tracer ---"));
            infoTitle.setTextColor(this.#classLoader.Color.parseColor("#FFC107"));
            infoTitle.setGravity(this.#classLoader.Gravity.CENTER.value);

            this.#tracerListLayout.addView(infoTitle);
            this.#tracerScrollView.addView(this.#tracerListLayout);
            this.#rightPanelLayout.addView(this.#tracerScrollView);
        }

        #createMenuScrollView() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#MATCH_PARENT);
            this.#menuScrollView = this.#classLoader.ScrollView.$new(this.#activity);
            const padding = pixelDensityToPixels(this.#activity, 8);
            this.#menuScrollView.setLayoutParams(layoutParams);
            this.#menuScrollView.setPadding(padding, padding, padding, padding);
        }

        #createMenuScrollLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT);
            this.#menuScrollLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#menuScrollLayout.setLayoutParams(layoutParams);
            this.#menuScrollLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
        }

        createMenuOptionsLayout(colorOn, colorOff) {
            this.#createMenuScrollView();
            this.#createMenuScrollLayout();
            this.#colorOn = colorOn;
            this.#colorOff = colorOff;
        }

        createMenuStart(title, size, color) {
            size = pixelDensityToPixels(this.#activity, size)
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
            this.#menuStart = this.#classLoader.TextView.$new(this.#activity)
            this.#menuStart.setLayoutParams(layoutParams)
            this.#menuStart.setText(this.#classLoader.String.$new(title))
            this.#menuStart.setTextSize(size)
            this.#menuStart.setTextColor(this.#classLoader.Color.parseColor(color))
            this.#menuStart.setBackgroundColor(this.#classLoader.Color.WHITE.value)
        }

        #drawContentView() { this.#activity.addContentView(this.#contentView, this.#contentView.getLayoutParams()) }
        #drawMainLayout() { this.#contentView.addView(this.#mainLayout) }
        #drawMenuStart() { this.#mainLayout.addView(this.#menuStart) }

        #buildExpandedMenu() {
            this.#menuBarLayout.addView(this.#menuBarTitle);
            this.#menuLayout.addView(this.#menuBarLayout);
            this.#createPanelsContainerLayout();
            this.#menuLayout.addView(this.#panelsContainerLayout);
            this.#createLeftPanelLayout();
            this.#menuScrollView.addView(this.#menuScrollLayout);
            this.#leftPanelLayout.addView(this.#menuScrollView);
            this.#panelsContainerLayout.addView(this.#leftPanelLayout);
            this.#createRightPanelLayout();
            this.#panelsContainerLayout.addView(this.#rightPanelLayout);
        }
        
        // NOVO: Adiciona uma função à lista da UI, com evento de clique para copiar
        #addFunctionToUI(funcInfo) {
            if (!this.#tracerListLayout) return;
            const context = this.#activity.getApplicationContext();
            
            const funcTextView = this.#classLoader.TextView.$new(this.#activity);
            const displayText = funcInfo.knownName ? `${funcInfo.knownName} (Chamada!)` : funcInfo.name;
            
            if(funcInfo.knownName) {
                 funcTextView.setTextColor(this.#classLoader.Color.parseColor("#00FF00")); // Verde para conhecidas
            } else {
                 funcTextView.setTextColor(this.#classLoader.Color.parseColor("#FFEB3B")); // Amarelo para interações
            }

            funcTextView.setText(this.#classLoader.String.$new(displayText));

            // Adiciona o listener de clique para copiar
            const OnClickListener = this.#classLoader.View_OnClickListener;
            const clickListener = Java.registerClass({
                name: 'com.example.CopyClickListener' + Math.random().toString(36).substring(2),
                implements: [OnClickListener],
                methods: {
                    onClick(view) {
                        const clipboard = context.getSystemService("clipboard");
                        const label = funcInfo.knownName || funcInfo.name;
                        const textToCopy = `${label}: ${funcInfo.name}`;
                        const clip = this.#classLoader.ClipData.newPlainText(label, textToCopy);
                        clipboard.setPrimaryClip(clip);
                        showToast(`Copiado: ${textToCopy}`, 0);
                    }
                }
            });
            funcTextView.setOnClickListener(clickListener.$new());
            this.#tracerListLayout.addView(funcTextView);
        }
        
        // NOVO: Atualiza a lista de funções na UI
        updateFunctionListUI(functionList) {
             Java.scheduleOnMainThread(() => {
                const title = this.#tracerListLayout.getChildAt(0);
                this.#tracerListLayout.removeAllViews();
                this.#tracerListLayout.addView(title);

                if (functionList.length === 0) {
                    const waitingView = this.#classLoader.TextView.$new(this.#activity);
                    waitingView.setText(this.#classLoader.String.$new("Aguardando interações..."));
                    waitingView.setTextColor(this.#classLoader.Color.parseColor("#FFFFFF"));
                    this.#tracerListLayout.addView(waitingView);
                } else {
                    functionList.forEach(funcInfo => {
                        this.#addFunctionToUI(funcInfo);
                    });
                }
            });
        }
        
        #createOptionClickEvent(id, optionView, callbacks) {
            const classLoader = this.#classLoader, colorOn = this.#colorOn, colorOff = this.#colorOff, self = this;
            const optionOnClickListener = Java.registerClass({
                name: "com.example." + id,
                implements: [classLoader.View_OnClickListener],
                methods: {
                    onClick(p1) {
                        if (!self.#options[id].state) {
                            p1.setBackgroundColor(classLoader.Color.parseColor(colorOn)); self.#options[id].state = true; callbacks.on()
                        } else {
                            p1.setBackgroundColor(classLoader.Color.parseColor(colorOff)); self.#options[id].state = false; callbacks.off()
                        }
                    }
                }
            })
            optionView.setOnClickListener(optionOnClickListener.$new())
        }
        
        addOption(id, name, callbacks) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT), padding = pixelDensityToPixels(this.#activity, 5), option = this.#classLoader.TextView.$new(this.#activity), margin = pixelDensityToPixels(this.#activity, 10);
            option.setText(this.#classLoader.String.$new(name));
            option.setBackgroundColor(this.#classLoader.Color.parseColor(this.#colorOff));
            option.setTextColor(this.#classLoader.Color.parseColor("#EFEFEF"));
            layoutParams.setMargins(0, 0, 0, margin);
            option.setLayoutParams(layoutParams);
            option.setPadding(padding, padding, 0, padding);
            this.#menuScrollLayout.addView(option);
            this.#options[id] = { callbacks, optionView: option, state: false };
            this.#createOptionClickEvent(id, option, callbacks);
        }
        
        turnOffAllOptions() {
            for (const id in this.#options) {
                const optionData = this.#options[id];
                if (optionData.state) {
                    optionData.optionView.setBackgroundColor(this.#classLoader.Color.parseColor(this.#colorOff));
                    optionData.state = false;
                    optionData.callbacks.off();
                }
            }
        }
        
        addText(text, textSize, textColor) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT), margin = pixelDensityToPixels(this.#activity, 5), textView = this.#classLoader.TextView.$new(this.#activity);
            textView.setText(this.#classLoader.String.$new(text));
            textView.setTextSize(textSize);
            textView.setTextColor(this.#classLoader.Color.parseColor(textColor));
            layoutParams.setMargins(0, 0, 0, margin);
            textView.setLayoutParams(layoutParams);
            this.#menuScrollLayout.addView(textView);
        }
        
        addSeekBar(textValue, initialValue, minValue, maxValue, callback) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT), margin = pixelDensityToPixels(this.#activity, 1), seekBar = this.#classLoader.SeekBar.$new(this.#activity, null, 0, Java.use("android.R$style").Widget_Holo_SeekBar.value), textView = this.#classLoader.TextView.$new(this.#activity);
            seekBar.setMax(maxValue - minValue);
            seekBar.setProgress(initialValue - minValue);
            layoutParams.setMargins(0, 0, 0, margin);
            seekBar.setLayoutParams(layoutParams);
            const text = Java.use("java.lang.String").$new(textValue + " " + initialValue);
            textView.setText(text)
            textView.setTextColor(this.#classLoader.Color.parseColor("#EFEFEF"))
            const SeekBarChangeListener = Java.use("android.widget.SeekBar$OnSeekBarChangeListener");
            const SeekBarChangeListenerImplementation = Java.registerClass({
                name: "com.example.SeekBarChangeListener" + Math.floor(Math.random() * 1000),
                implements: [SeekBarChangeListener],
                methods: {
                    onProgressChanged(seekBar, progress, fromUser) {
                        const value = progress + minValue, text = Java.use("java.lang.String").$new(textValue + " " + value);
                        textView.setText(text);
                        if (fromUser) callback(value, "move");
                    },
                    onStartTrackingTouch(seekBar) { callback(seekBar.getProgress() + minValue, "start"); },
                    onStopTrackingTouch(seekBar) { callback(seekBar.getProgress() + minValue, "end"); }
                }
            });
            seekBar.setOnSeekBarChangeListener(SeekBarChangeListenerImplementation.$new());
            this.#menuScrollLayout.addView(textView);
            this.#menuScrollLayout.addView(seekBar);
            textView.setLayoutParams(layoutParams);
            textView.setGravity(this.#classLoader.Gravity.CENTER.value);
        }
        
        #createMainLayoutEvent() {
            const mainLayout = this.#mainLayout, menuLayout = this.#menuLayout, menuStart = this.#menuStart, classLoader = this.#classLoader;
            let initialX = 0, initialY = 0, isMove = false, isMenuLayout = false, initialTouchTime = 0;
            const MainLayoutOnTouchListener = Java.registerClass({
                name: "com.example.MainLayoutEvent",
                implements: [classLoader.View_OnTouchListener],
                methods: {
                    onTouch(view, event) {
                        const menuHeight = menuLayout.getHeight();
                        switch (event.getAction()) {
                            case classLoader.MotionEvent.ACTION_DOWN.value: initialX = view.getX() - event.getRawX(); initialY = view.getY() - event.getRawY(); isMove = false; initialTouchTime = Date.now(); break;
                            case classLoader.MotionEvent.ACTION_UP.value:
                                if (!isMove) {
                                    if (!isMenuLayout) {
                                        const currentY = mainLayout.getY(), targetY = (currentY + menuHeight / 2) - menuStart.getHeight() / 1.5;
                                        mainLayout.removeView(menuStart); mainLayout.addView(menuLayout); mainLayout.setY(targetY); isMenuLayout = true;
                                    } else {
                                        const currentY = mainLayout.getY(), targetY = (currentY - menuHeight / 2) + menuStart.getHeight() / 1.5;
                                        mainLayout.removeView(menuLayout); mainLayout.addView(menuStart); mainLayout.setY(targetY); isMenuLayout = false;
                                    }
                                }
                                break;
                            case classLoader.MotionEvent.ACTION_MOVE.value: view.setX(event.getRawX() + initialX); view.setY(event.getRawY() + initialY); if (Date.now() - initialTouchTime > 200) isMove = true; break;
                            default: return false;
                        }
                        return true;
                    }
                }
            })
            this.#mainLayout.setOnTouchListener(MainLayoutOnTouchListener.$new())
        }

        start() {
            this.#drawContentView();
            this.#drawMainLayout();
            this.#drawMenuStart();
            this.#buildExpandedMenu();
            this.#createMainLayoutEvent();
        }
    }

    let menu = null;
    
    // ====================================================================================================
    // == INÍCIO DA LÓGICA DO FUNCTION TRACER =============================================================
    // ====================================================================================================

    let functionCallStats = {};
    let activeHooks = [];
    let displayInterval = null;

    // Dicionário de funções conhecidas para fácil identificação
    const knownFunctions = {
        "_ZN10zF9VgaBKxR10tMaombuGXrEdddii": "Put Explosion",
        "_ZN10W6NzgawMJy10iPzUgaQKcQEdddRK10C8THgaTQxFP10MpGzgariDy": "Player Hurt"
        // Adicione outras funções conhecidas aqui
    };

    function startFunctionTracer() {
        if (activeHooks.length > 0) return; // Já está rodando

        functionCallStats = {};
        const exports = Module.enumerateExports('libqplay.so');
        const NOISE_THRESHOLD = 20; // Funções chamadas mais de 20 vezes por segundo são ruído

        exports.forEach(exp => {
            if (exp.type === 'function') {
                try {
                    const listener = Interceptor.attach(exp.address, {
                        onEnter: function(args) {
                            const name = exp.name;
                            if (!functionCallStats[name]) {
                                functionCallStats[name] = {
                                    name: name,
                                    knownName: knownFunctions[name] || null,
                                    count: 0,
                                    lastCalled: 0,
                                    isInteraction: false
                                };
                            }
                            functionCallStats[name].count++;
                            functionCallStats[name].lastCalled = Date.now();
                        }
                    });
                    activeHooks.push(listener);
                } catch (e) {
                    // console.log(`Could not hook ${exp.name}: ${e.message}`);
                }
            }
        });

        // Intervalo para analisar as chamadas e atualizar a UI
        displayInterval = setInterval(() => {
            const now = Date.now();
            let interactionCalls = [];
            
            for (const name in functionCallStats) {
                const func = functionCallStats[name];

                // Filtro de ruído: ignora funções chamadas muito frequentemente
                const secondsSinceFirstCall = (now - (func.firstCalled || now)) / 1000 || 1;
                const callsPerSecond = func.count / secondsSinceFirstCall;
                if (callsPerSecond > NOISE_THRESHOLD) {
                    continue; // É ruído, pular
                }

                // Considera uma interação se foi chamada no último segundo
                if (now - func.lastCalled < 1000) {
                    interactionCalls.push(func);
                }
            }

            // Ordena a lista: conhecidas primeiro, depois as mais recentes
            interactionCalls.sort((a, b) => {
                if (a.knownName && !b.knownName) return -1;
                if (!a.knownName && b.knownName) return 1;
                return b.lastCalled - a.lastCalled;
            });
            
            if (menu) {
                menu.updateFunctionListUI(interactionCalls);
            }

        }, 1000); // Roda a análise a cada segundo

        showToast("Function Tracer Ativado!", 0);
    }
    
    function stopFunctionTracer() {
        if (displayInterval) {
            clearInterval(displayInterval);
            displayInterval = null;
        }
        activeHooks.forEach(hook => hook.detach());
        activeHooks = [];
        functionCallStats = {};
        if (menu) menu.updateFunctionListUI([]);
        showToast("Function Tracer Desativado.", 0);
    }
    
    // ====================================================================================================
    // == FIM DA LÓGICA DO FUNCTION TRACER ================================================================
    // ====================================================================================================

    Java.perform(function() {
        Java.scheduleOnMainThread(function() {
            const classLoader = getClassLoader();
            const mainActivity = getMainActivity(classLoader);
            menu = new Menu(classLoader, mainActivity)
            menu.createMenuStart("MENU", 15, "#006400")
            menu.createMenuLayout("#18122B", 420, 300)
            menu.createMenuBarLayout("#635985")
            menu.createMenuBarTitle("EngModMobile", "#FFC107")
            menu.createMenuOptionsLayout("#443C68", "#393053")
            
            // Adicionando a nova opção do Function Tracer
            menu.addText("--- Análise de Funções ---", 12, "#FFC107")
            menu.addOption("functionTracer", "Rastrear Funções", {
                on: startFunctionTracer,
                off: stopFunctionTracer
            })

            // Adicione outras opções do seu menu antigo se desejar
            menu.addText("--- Utilitários ---", 12, "#FFFFFF")
            // menu.addOption("unhit", "Unhit (God Mode)", call_unhit) // Exemplo

            menu.start()
        })
    })

    function getFunc(lib, func, type, params) {
        return new NativeFunction(Module.findExportByName(lib, func), type, params);
    }

    function createTString(str) {
        var str_pointer = malloc(4), str_struct = malloc(str.length + 8);
        str_pointer.writePointer(str_struct);
        str_struct.writeInt(str.length);
        ptr(parseInt(str_struct) + 4).writeInt(1);
        ptr(parseInt(str_struct) + 8).writeUtf8String(str);
        return str_pointer;
    }

    function readTString(str) {
        if (str && !str.isNull()) {
            var pstr = str.readPointer();
            if (pstr && !pstr.isNull()) {
                var strlen = pstr.readInt();
                if (strlen > 0) return ptr(parseInt(pstr) + 8).readCString(strlen);
            }
        }
        return null;
    }

    function click() {
        Java.perform(() => Java.scheduleOnMainThread(() => {
            let time = Java.use("android.os.SystemClock").uptimeMillis(),
                event = Java.use("android.view.MotionEvent").obtain(time, time + 50, 0, 500, 500, 0);
            getMainActivity(getClassLoader()).dispatchTouchEvent(event);
            console.log("Anti-AFK click performed.");
        }));
    }

}, 5000)
