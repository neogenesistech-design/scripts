// ... (código acima inalterado, incluindo getClassLoader, showToast, etc.)

// MODIFICADO: call_explode usa o tempo de explosão dinâmico
const call_explode = { 
    on() { 
        if (!explosionsInterval) 
            explosionsInterval = setInterval(() => { canExplode = true; }, currentExplosionTime); 
    }, 
    off() { 
        if (explosionsInterval) { 
            clearInterval(explosionsInterval); 
            explosionsInterval = null; 
            canExplode = false; 
        } 
    } 
};

// ... (código anti-afk e chamadas call_unhit, call_autoOFF, call_wallhack inalterados)

// ========================================================================
// Criação da Interface Gráfica (UI) - CORRIGIDA
// ========================================================================
Java.perform(function () {
    Java.scheduleOnMainThread(function () {
            const classLoader = getClassLoader();
            const mainActivity = getMainActivity(classLoader);
            const Gravity = classLoader.Gravity;
            const View = classLoader.View;

            const COLOR_OFF = classLoader.Color.parseColor("#80000000");
            const COLOR_ON = classLoader.Color.parseColor("#80008000");
            const PADDING = pixelDensityToPixels(mainActivity, 8);
            const MARGIN = pixelDensityToPixels(mainActivity, 2);

            // FUNÇÃO createToggleButton (INALTERADA - AGORA É SÓ PARA TOGGLE)
            function createToggleButton(text, callbacks, startOn = false, isCycleButton = false) {
                const button = classLoader.TextView.$new(mainActivity);
                let isOn = startOn;
                
                const reset = () => {
                    isOn = false; 
                    button.setBackgroundColor(COLOR_OFF);
                    if (callbacks.off) callbacks.off();
                };
                
                button.setText(classLoader.String.$new(text));
                button.setTextColor(classLoader.Color.WHITE.value);
                
                // Removemos a lógica de isCycleButton daqui, é só toggle.
                button.setBackgroundColor(isOn ? COLOR_ON : COLOR_OFF);
                
                button.setPadding(PADDING, PADDING, PADDING, PADDING);
                
                const layoutParams = classLoader.LinearLayout_LayoutParams.$new(-2, -2);
                layoutParams.setMargins(MARGIN, MARGIN, MARGIN, MARGIN);
                button.setLayoutParams(layoutParams);

                // Lógica de toggle
                button.setOnClickListener(Java.registerClass({
                    name: "com.example.ClickListener" + Math.random().toString(36).substring(2),
                    implements: [Java.use("android.view.View$OnClickListener")],
                    methods: {
                        onClick(v) {
                            isOn = !isOn;
                            v.setBackgroundColor(isOn ? COLOR_ON : COLOR_OFF);
                            if (isOn) { if (callbacks.on) callbacks.on(); }
                            else { if (callbacks.off) callbacks.off(); }
                        }
                    }
                }).$new());
                
                if (startOn) {
                    if (callbacks.on) callbacks.on(); 
                }

                return { view: button, reset: reset };
            }

            // FUNÇÃO createHoldButton (INALTERADA)
            function createHoldButton(text, action) { 
                const button = classLoader.TextView.$new(mainActivity); 
                let holdInterval = null; 
                button.setText(classLoader.String.$new(text)); 
                button.setTextColor(classLoader.Color.WHITE.value); 
                button.setBackgroundColor(COLOR_OFF); 
                button.setPadding(PADDING, PADDING, PADDING, PADDING); 
                const layoutParams = classLoader.LinearLayout_LayoutParams.$new(-2, -2); 
                layoutParams.setMargins(MARGIN, MARGIN, MARGIN, MARGIN); 
                button.setLayoutParams(layoutParams); 
                button.setOnTouchListener(Java.registerClass({ 
                    name: "com.example.TouchListener" + Math.random().toString(36).substring(2), 
                    implements: [classLoader.View_OnTouchListener], 
                    methods: { 
                        onTouch(v, event) { 
                            switch (event.getAction()) { 
                                case classLoader.MotionEvent.ACTION_DOWN.value: 
                                    action(); 
                                    holdInterval = setInterval(action, 100); 
                                    return true; 
                                case classLoader.MotionEvent.ACTION_UP.value: 
                                    if (holdInterval) clearInterval(holdInterval); 
                                    holdInterval = null; 
                                    return true; 
                            } 
                            return false; 
                        } 
                    } 
                }).$new()); 
                return button; 
            }

            // Container Vertical (INALTERADO)
            const explosionControlsVerticalLayout = classLoader.LinearLayout.$new(mainActivity);
            explosionControlsVerticalLayout.setOrientation(classLoader.LinearLayout.VERTICAL.value);
            explosionControlsVerticalLayout.setGravity(Gravity.CENTER_HORIZONTAL.value);
            const explosionGroupVerticalParams = classLoader.LinearLayout_LayoutParams.$new(-2, -2); // WRAP_CONTENT para não quebrar
            explosionControlsVerticalLayout.setLayoutParams(explosionGroupVerticalParams);
            
            // Layouts de Barra (INALTERADO)
            const mainBarLayout = classLoader.LinearLayout.$new(mainActivity);
            mainBarLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            mainBarLayout.setGravity(Gravity.CENTER.value);
            
            const bottomLayout = classLoader.LinearLayout.$new(mainActivity);
            const bottomParams = classLoader.LinearLayout_LayoutParams.$new(-1, -1);
            bottomLayout.setLayoutParams(bottomParams);
            bottomLayout.setGravity(Gravity.CENTER_HORIZONTAL.value | Gravity.BOTTOM.value);
            bottomLayout.addView(mainBarLayout);

            const topInfoTextView = classLoader.TextView.$new(mainActivity);
            topInfoTextView.setTextColor(classLoader.Color.WHITE.value);
            topInfoTextView.setShadowLayer(5, 0, 0, classLoader.Color.BLACK.value);
            
            const topBarLayout = classLoader.LinearLayout.$new(mainActivity); 
            topBarLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            topBarLayout.setGravity(Gravity.CENTER_VERTICAL.value);

            const topLayout = classLoader.LinearLayout.$new(mainActivity);
            const topParams = classLoader.LinearLayout_LayoutParams.$new(-1, -1);
            topLayout.setLayoutParams(topParams);
            topLayout.setGravity(Gravity.TOP.value | Gravity.CENTER_HORIZONTAL.value);
            topLayout.addView(topBarLayout); 

            // Botão de Esconder/Mostrar (INALTERADO)
            const call_hideCheats = {
                on() { mainBarLayout.setVisibility(View.VISIBLE.value); },
                off() { mainBarLayout.setVisibility(View.GONE.value); }
            };
            const hideCheatsButton = createToggleButton("[^]", call_hideCheats, true); 
            
            call_hideCheats.on(); // Inicia visível
            hideCheatsButton.view.setText(classLoader.String.$new("[^]")); // Próxima ação é ocultar

            hideCheatsButton.view.setOnClickListener(Java.registerClass({
                name: "com.example.HideClickListener" + Math.random().toString(36).substring(2),
                implements: [Java.use("android.view.View$OnClickListener")],
                methods: {
                    onClick(v) {
                        const isVisible = mainBarLayout.getVisibility() == View.VISIBLE.value;
                        if (isVisible) {
                            call_hideCheats.off(); 
                            v.setText(classLoader.String.$new("[v]")); 
                        } else {
                            call_hideCheats.on(); 
                            v.setText(classLoader.String.$new("[^]")); 
                        }
                    }
                }
            }).$new());

            topBarLayout.addView(hideCheatsButton.view);
            topBarLayout.addView(topInfoTextView);

            // Funções auxiliares (INALTERADO)
            const addAutoOffButton = (text, callbacks, startOn = false) => {
                const button = createToggleButton(text, callbacks, startOn);
                mainBarLayout.addView(button.view);
                autoOffButtons.push(button);
            };
            const addRegularButton = (text, callbacks, startOn = false) => {
                 const button = createToggleButton(text, callbacks, startOn);
                 mainBarLayout.addView(button.view);
            };
            
            // Adiciona botões (INALTERADO)
            addRegularButton("Revelar ADM", call_showAdmins, true);
            addAutoOffButton("Anti Afk", call_antiAfk, false); 
            addAutoOffButton("Unhit", call_unhit, false);
            addAutoOffButton("Auto Off", call_autoOFF, false);
            addAutoOffButton("Wall Hack", call_wallhack, false);

            // ========================================================================
            // Controle de Explosão: Raio + Tempo - CORRIGIDO/SIMPLIFICADO
            // ========================================================================
            
            // Variável para formatar o tempo (ex: 100ms ou 1s)
            const formatTime = (ms) => ms >= 1000 ? `${ms / 1000}s` : `${ms}ms`;

            // Função para atualizar o texto principal do botão de explosão (Raio + Tempo)
            const updateExplosionButtonText = (buttonView) => {
                const timeText = formatTime(currentExplosionTime);
                Java.scheduleOnMainThread(() => buttonView.setText(classLoader.String.$new(`Explodir: ${explosionRadius} (${timeText})`)));
            };

            // Função para mudar o tempo de explosão (para cima ou para baixo)
            const changeExplosionTime = (direction) => {
                const maxIndex = EXPLOSION_TIMES.length - 1;
                
                if (direction === 'up') {
                    currentExplosionTimeIndex = Math.min(maxIndex, currentExplosionTimeIndex + 1);
                } else if (direction === 'down') {
                    currentExplosionTimeIndex = Math.max(0, currentExplosionTimeIndex - 1);
                }
                
                currentExplosionTime = EXPLOSION_TIMES[currentExplosionTimeIndex];

                if (explosionsInterval) {
                    // Reinicia o intervalo se a explosão estiver ativa
                    clearInterval(explosionsInterval);
                    explosionsInterval = setInterval(() => { canExplode = true; }, currentExplosionTime);
                    showToast(`Tempo ajustado para ${formatTime(currentExplosionTime)}`, 0); 
                }
                
                updateExplosionButtonText(explosionButton.view);
            };

            // --- Controles de Raio ---
            const explosionRadiusControlLayout = classLoader.LinearLayout.$new(mainActivity);
            explosionRadiusControlLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            const explosionRadiusControlLayoutParams = classLoader.LinearLayout_LayoutParams.$new(-2, -2);
            explosionRadiusControlLayout.setLayoutParams(explosionRadiusControlLayoutParams);
            explosionRadiusControlLayout.setGravity(Gravity.CENTER.value);
            
            // Cria o botão principal (que agora mostra Raio e Tempo)
            const explosionButton = createToggleButton(`Explodir: ${explosionRadius} (${formatTime(currentExplosionTime)})`, call_explode);
            autoOffButtons.push(explosionButton);

            // Ações de Raio (mantidas)
            const updateRadiusText = () => { 
                explosionRadius = Math.max(1, explosionRadius); // Garante que o raio mínimo seja 1
                updateExplosionButtonText(explosionButton.view); 
            };
            const decreaseRadiusAction = () => { explosionRadius = Math.max(1, explosionRadius - 1); updateRadiusText(); };
            const increaseRadiusAction = () => { explosionRadius = Math.min(100, explosionRadius + 1); updateRadiusText(); };
            
            explosionRadiusControlLayout.addView(createHoldButton("<", decreaseRadiusAction)); // Diminui Raio
            explosionRadiusControlLayout.addView(explosionButton.view);
            explosionRadiusControlLayout.addView(createHoldButton(">", increaseRadiusAction)); // Aumenta Raio

            // --- Controles de Tempo ---
            const explosionTimeControlLayout = classLoader.LinearLayout.$new(mainActivity);
            explosionTimeControlLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            const explosionTimeControlLayoutParams = classLoader.LinearLayout_LayoutParams.$new(-2, -2);
            explosionTimeControlLayout.setLayoutParams(explosionTimeControlLayoutParams);
            explosionTimeControlLayout.setGravity(Gravity.CENTER.value);

            // Ações de Tempo
            const decreaseTimeAction = () => changeExplosionTime('down');
            const increaseTimeAction = () => changeExplosionTime('up');

            explosionTimeControlLayout.addView(createHoldButton("<< Time", decreaseTimeAction)); // Diminui Tempo
            explosionTimeControlLayout.addView(createHoldButton("Time >>", increaseTimeAction)); // Aumenta Tempo

            // Adiciona os grupos de controle ao layout vertical
            explosionControlsVerticalLayout.addView(explosionRadiusControlLayout); // Raio + Toggle
            explosionControlsVerticalLayout.addView(explosionTimeControlLayout); // Tempo

            // Adiciona o grupo de explosão (vertical) ao contêiner principal (horizontal)
            mainBarLayout.addView(explosionControlsVerticalLayout);

            // Adiciona os layouts principais na tela (INALTERADO)
            mainActivity.addContentView(topLayout, topParams);
            mainActivity.addContentView(bottomLayout, bottomParams);

            // Lógica de atualização do texto de info (INALTERADO)
            setInterval(() => {
                const props = getPlayerProperties(activeplayer);
                Java.scheduleOnMainThread(function() {
                    const infoText = `  Nome: ${props.nick} | ID: ${props.account} | Pos: (${props.x.toFixed(2)}, ${props.y.toFixed(2)})`;
                    topInfoTextView.setText(classLoader.String.$new(infoText));
                });
            }, 500);
        });
    });

    // Funções de Baixo Nível (Inalterado)
    function getFunc(lib, func, type, params) { return new NativeFunction(Module.findExportByName(lib, func), type, params); }
    function createTString(str) { var str_pointer = malloc(4); var str_struct = malloc(str.length + 8); str_pointer.writePointer(str_struct); str_struct.writeInt(str.length); ptr(parseInt(str_struct) + 4).writeInt(1); ptr(parseInt(str_struct) + 8).writeUtf8String(str); return str_pointer; }
    function readTString(str) { if (!str.isNull() && parseInt(str) != 0) { var pstr = str.readPointer(); if (!pstr.isNull()) { var strlen = pstr.readInt(); if (strlen > 0) return ptr(parseInt(pstr) + 8).readCString(strlen); } } return ""; }
    
    // MODIFICADO: Função click() para usar o canto superior direito (X = Largura - 1, Y = 1)
    function click() { 
        Java.perform(() => 
            Java.scheduleOnMainThread(() => { 
                const classLoader = getClassLoader();
                const mainActivity = getMainActivity(classLoader);
                const context = Java.use("android.app.ActivityThread").currentApplication().getApplicationContext();
                
                const screen_width = getScreenWidth(context);
                const targetX = screen_width - 1;
                const targetY = 1;

                let time = Java.use("android.os.SystemClock").uptimeMillis(); 
                let event = Java.use("android.view.MotionEvent").obtain(time, time + 50, 0, targetX, targetY, 0); 
                mainActivity.dispatchTouchEvent(event); 
            })
        ); 
    }
    // FIM DA MODIFICAÇÃO DE click()
}, 8000);
