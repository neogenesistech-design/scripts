setTimeout(() => {
    // Função malloc para alocar memória em código nativo (libc)
    var malloc = getFunc("libc.so", "malloc", "pointer", ["int"])

    // Variável para gerenciar toasts e evitar sobreposição
    let currentToast = null;

    // Função que carrega classes Android necessárias para criar interface de usuário e manipular eventos
    function getClassLoader() {
        const classLoader = {
            Gravity: Java.use("android.view.Gravity"),
            TextView: Java.use("android.widget.TextView"),
            LinearLayout: Java.use("android.widget.LinearLayout"),
            ViewGroup_LayoutParams: Java.use("android.view.ViewGroup$LayoutParams"),
            LinearLayout_LayoutParams: Java.use("android.widget.LinearLayout$LayoutParams"),
            Color: Java.use("android.graphics.Color"),
            ActivityThread: Java.use("android.app.ActivityThread"),
            ActivityThread_ActivityClientRecord: Java.use("android.app.ActivityThread$ActivityClientRecord"),
            View_OnTouchListener: Java.use("android.view.View$OnTouchListener"),
            MotionEvent: Java.use("android.view.MotionEvent"),
            String: Java.use("java.lang.String"),
            ScrollView: Java.use("android.widget.ScrollView"),
            View_OnClickListener: Java.use("android.view.View$OnClickListener"),
            SeekBar: Java.use("android.widget.SeekBar")
        }
        return classLoader
    }

    // Função que converte unidade dp (density independent pixels) para pixels reais na tela
    function pixelDensityToPixels(context, dp) {
        const density = context.getResources().getDisplayMetrics().density.value
        return parseInt(dp * density)
    }

    // Função para obter a Activity principal atual do aplicativo
    function getMainActivity(classLoader) {
        const activityThread = classLoader.ActivityThread.sCurrentActivityThread.value
        const mActivities = activityThread.mActivities.value
        const activityClientRecord = Java.cast(mActivities.valueAt(0), classLoader.ActivityThread_ActivityClientRecord)
        return activityClientRecord.activity.value
    }

    // Função para exibir um Toast, cancelando o anterior se existir
    function showToast(text, time = 1) { // 1 = Long, 0 = Short
        Java.perform(() => {
            Java.scheduleOnMainThread(function() {
                if (currentToast) {
                    currentToast.cancel();
                }
                var toast = Java.use("android.widget.Toast");
                var newToast = toast.makeText(Java.use("android.app.ActivityThread").currentApplication().getApplicationContext(),
                    Java.use("java.lang.String").$new(text), time);
                newToast.show();
                currentToast = newToast;
            });
        });
    }

    // Classe Menu para facilitar criar e gerenciar um menu na interface usando widgets Android
    class Menu {
        #classLoader; #activity; #MATCH_PARENT; #WRAP_CONTENT; #contentView; #mainLayout; #menuStart; #menuLayout; #menuBarLayout; #menuBarTitle; #options; #colorOn; #colorOff;
        #panelsContainerLayout; #leftPanelLayout; #rightPanelLayout; #menuScrollView; #menuScrollLayout; #entityScrollView; #entityListLayout;

        constructor(classLoader, activity) {
            this.#classLoader = classLoader
            this.#activity = activity
            this.#MATCH_PARENT = classLoader.LinearLayout_LayoutParams.MATCH_PARENT.value
            this.#WRAP_CONTENT = classLoader.LinearLayout_LayoutParams.WRAP_CONTENT.value
            this.#options = {}
            this.#createContentView()
            this.#createMainLayout()
        }

        #createContentView() {
            this.#contentView = this.#classLoader.LinearLayout.$new(this.#activity)
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#MATCH_PARENT)
            this.#contentView.setLayoutParams(layoutParams)
            this.#contentView.setGravity(this.#classLoader.Gravity.CENTER.value)
            this.#contentView.setBackgroundColor(this.#classLoader.Color.TRANSPARENT.value)
        }

        #createMainLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
            this.#mainLayout = this.#classLoader.LinearLayout.$new(this.#activity)
            this.#mainLayout.setLayoutParams(layoutParams)
        }

        createMenuLayout(color, width, height) {
            const widthPx = pixelDensityToPixels(this.#activity, width);
            const heightPx = pixelDensityToPixels(this.#activity, height);
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(widthPx, heightPx);
            this.#menuLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#menuLayout.setLayoutParams(layoutParams);
            this.#menuLayout.setBackgroundColor(this.#classLoader.Color.parseColor(color));
            this.#menuLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
        }

        createMenuBarLayout(color) {
            const padding = pixelDensityToPixels(this.#activity, 10)
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT)
            this.#menuBarLayout = this.#classLoader.LinearLayout.$new(this.#activity)
            this.#menuBarLayout.setLayoutParams(layoutParams)
            this.#menuBarLayout.setBackgroundColor(this.#classLoader.Color.parseColor(color))
            this.#menuBarLayout.setPadding(padding, padding, 0, padding)
        }

        createMenuBarTitle(title, color) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
            this.#menuBarTitle = this.#classLoader.TextView.$new(this.#activity)
            this.#menuBarTitle.setLayoutParams(layoutParams)
            this.#menuBarTitle.setText(this.#classLoader.String.$new(title))
            this.#menuBarTitle.setTextColor(this.#classLoader.Color.parseColor(color))
        }

        #createPanelsContainerLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#MATCH_PARENT);
            this.#panelsContainerLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#panelsContainerLayout.setLayoutParams(layoutParams);
            this.#panelsContainerLayout.setOrientation(this.#classLoader.LinearLayout.HORIZONTAL.value);
        }

        #createLeftPanelLayout() {
            // O peso 1.0 define a proporção do painel.
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(0, this.#MATCH_PARENT, 1.0);
            this.#leftPanelLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#leftPanelLayout.setLayoutParams(layoutParams);
            this.#leftPanelLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
        }

        #createRightPanelLayout() {
            // O peso 1.5 faz este painel ser 50% mais largo que o da esquerda.
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(0, this.#MATCH_PARENT, 1.5);
            const padding = pixelDensityToPixels(this.#activity, 8);
            this.#rightPanelLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#rightPanelLayout.setLayoutParams(layoutParams);
            this.#rightPanelLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
            this.#rightPanelLayout.setPadding(padding, padding, padding, padding);

            this.#entityScrollView = this.#classLoader.ScrollView.$new(this.#activity);
            this.#entityListLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#entityListLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);

            const infoTitle = this.#classLoader.TextView.$new(this.#activity);
            infoTitle.setText(this.#classLoader.String.$new("--- Entity Auto-Explorer ---"));
            infoTitle.setTextColor(this.#classLoader.Color.parseColor("#FFC107"));
            infoTitle.setGravity(this.#classLoader.Gravity.CENTER.value);

            this.#entityListLayout.addView(infoTitle);
            this.#entityScrollView.addView(this.#entityListLayout);
            this.#rightPanelLayout.addView(this.#entityScrollView);
        }

        #createMenuScrollView() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#MATCH_PARENT);
            this.#menuScrollView = this.#classLoader.ScrollView.$new(this.#activity);
            const padding = pixelDensityToPixels(this.#activity, 8);
            this.#menuScrollView.setLayoutParams(layoutParams);
            this.#menuScrollView.setPadding(padding, padding, padding, padding);
        }

        #createMenuScrollLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT);
            this.#menuScrollLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#menuScrollLayout.setLayoutParams(layoutParams);
            this.#menuScrollLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
        }

        createMenuOptionsLayout(colorOn, colorOff) {
            this.#createMenuScrollView();
            this.#createMenuScrollLayout();
            this.#colorOn = colorOn;
            this.#colorOff = colorOff;
        }

        createMenuStart(title, size, color) {
            size = pixelDensityToPixels(this.#activity, size)
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
            this.#menuStart = this.#classLoader.TextView.$new(this.#activity)
            this.#menuStart.setLayoutParams(layoutParams)
            this.#menuStart.setText(this.#classLoader.String.$new(title))
            this.#menuStart.setTextSize(size)
            this.#menuStart.setTextColor(this.#classLoader.Color.parseColor(color))
            this.#menuStart.setBackgroundColor(this.#classLoader.Color.WHITE.value)
        }

        #drawContentView() { this.#activity.addContentView(this.#contentView, this.#contentView.getLayoutParams()) }
        #drawMainLayout() { this.#contentView.addView(this.#mainLayout) }
        #drawMenuStart() { this.#mainLayout.addView(this.#menuStart) }

        #buildExpandedMenu() {
            this.#menuBarLayout.addView(this.#menuBarTitle);
            this.#menuLayout.addView(this.#menuBarLayout);

            this.#createPanelsContainerLayout();
            this.#menuLayout.addView(this.#panelsContainerLayout);

            this.#createLeftPanelLayout();
            this.#menuScrollView.addView(this.#menuScrollLayout);
            this.#leftPanelLayout.addView(this.#menuScrollView);
            this.#panelsContainerLayout.addView(this.#leftPanelLayout);

            this.#createRightPanelLayout();
            this.#panelsContainerLayout.addView(this.#rightPanelLayout);
        }

        #clearEntityListUI() {
            if (this.#entityListLayout) {
                // Guarda o título e remove todo o resto
                const title = this.#entityListLayout.getChildAt(0);
                this.#entityListLayout.removeAllViews();
                this.#entityListLayout.addView(title);
            }
        }

        #addEntityToUI(text) {
            if (this.#entityListLayout) {
                const entityTextView = this.#classLoader.TextView.$new(this.#activity);
                entityTextView.setTextColor(this.#classLoader.Color.parseColor("#AED2FF"));
                entityTextView.setText(this.#classLoader.String.$new(text));
                this.#entityListLayout.addView(entityTextView);
            }
        }

        updateEntityListUI(entityTexts) {
            Java.scheduleOnMainThread(() => {
                this.#clearEntityListUI();
                if (entityTexts.length === 0) {
                     this.#addEntityToUI("Nenhuma entidade encontrada.");
                } else {
                    entityTexts.forEach(text => {
                        this.#addEntityToUI(text);
                    });
                }
            });
        }

        #createOptionClickEvent(id, optionView, callbacks) {
            const classLoader = this.#classLoader, colorOn = this.#colorOn, colorOff = this.#colorOff, self = this;
            const optionOnClickListener = Java.registerClass({
                name: "com.example." + id,
                implements: [classLoader.View_OnClickListener],
                methods: {
                    onClick(p1) {
                        if (!self.#options[id].state) {
                            p1.setBackgroundColor(classLoader.Color.parseColor(colorOn)); self.#options[id].state = true; callbacks.on()
                        } else {
                            p1.setBackgroundColor(classLoader.Color.parseColor(colorOff)); self.#options[id].state = false; callbacks.off()
                        }
                    }
                }
            })
            optionView.setOnClickListener(optionOnClickListener.$new())
        }

        addOption(id, name, callbacks) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT), padding = pixelDensityToPixels(this.#activity, 5), option = this.#classLoader.TextView.$new(this.#activity), margin = pixelDensityToPixels(this.#activity, 10);
            option.setText(this.#classLoader.String.$new(name));
            option.setBackgroundColor(this.#classLoader.Color.parseColor(this.#colorOff));
            option.setTextColor(this.#classLoader.Color.parseColor("#EFEFEF"));
            layoutParams.setMargins(0, 0, 0, margin);
            option.setLayoutParams(layoutParams);
            option.setPadding(padding, padding, 0, padding);
            this.#menuScrollLayout.addView(option);
            this.#options[id] = { callbacks, optionView: option, state: false };
            this.#createOptionClickEvent(id, option, callbacks);
        }

        turnOffAllOptions() {
            for (const id in this.#options) {
                const optionData = this.#options[id];
                if (optionData.state) {
                    optionData.optionView.setBackgroundColor(this.#classLoader.Color.parseColor(this.#colorOff));
                    optionData.state = false;
                    optionData.callbacks.off();
                }
            }
        }

        addText(text, textSize, textColor) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT), margin = pixelDensityToPixels(this.#activity, 5), textView = this.#classLoader.TextView.$new(this.#activity);
            textView.setText(this.#classLoader.String.$new(text));
            textView.setTextSize(textSize);
            textView.setTextColor(this.#classLoader.Color.parseColor(textColor));
            layoutParams.setMargins(0, 0, 0, margin);
            textView.setLayoutParams(layoutParams);
            this.#menuScrollLayout.addView(textView);
        }

        addSeekBar(textValue, initialValue, minValue, maxValue, callback) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT), margin = pixelDensityToPixels(this.#activity, 1), seekBar = this.#classLoader.SeekBar.$new(this.#activity, null, 0, Java.use("android.R$style").Widget_Holo_SeekBar.value), textView = this.#classLoader.TextView.$new(this.#activity);
            seekBar.setMax(maxValue - minValue);
            seekBar.setProgress(initialValue - minValue);
            layoutParams.setMargins(0, 0, 0, margin);
            seekBar.setLayoutParams(layoutParams);
            const text = Java.use("java.lang.String").$new(textValue + " " + initialValue);
            textView.setText(text)
            textView.setTextColor(this.#classLoader.Color.parseColor("#EFEFEF"))
            const SeekBarChangeListener = Java.use("android.widget.SeekBar$OnSeekBarChangeListener");
            const SeekBarChangeListenerImplementation = Java.registerClass({
                name: "com.example.SeekBarChangeListener" + Math.floor(Math.random() * 1000),
                implements: [SeekBarChangeListener],
                methods: {
                    onProgressChanged(seekBar, progress, fromUser) {
                        const value = progress + minValue, text = Java.use("java.lang.String").$new(textValue + " " + value);
                        textView.setText(text);
                        if (fromUser) callback(value, "move");
                    },
                    onStartTrackingTouch(seekBar) { callback(seekBar.getProgress() + minValue, "start"); },
                    onStopTrackingTouch(seekBar) { callback(seekBar.getProgress() + minValue, "end"); }
                }
            });
            seekBar.setOnSeekBarChangeListener(SeekBarChangeListenerImplementation.$new());
            this.#menuScrollLayout.addView(textView);
            this.#menuScrollLayout.addView(seekBar);
            textView.setLayoutParams(layoutParams);
            textView.setGravity(this.#classLoader.Gravity.CENTER.value);
        }

        #createMainLayoutEvent() {
            const mainLayout = this.#mainLayout, menuLayout = this.#menuLayout, menuStart = this.#menuStart, classLoader = this.#classLoader;
            let initialX = 0, initialY = 0, isMove = false, isMenuLayout = false, initialTouchTime = 0;
            const MainLayoutOnTouchListener = Java.registerClass({
                name: "com.example.MainLayoutEvent",
                implements: [classLoader.View_OnTouchListener],
                methods: {
                    onTouch(view, event) {
                        const menuHeight = menuLayout.getHeight();
                        switch (event.getAction()) {
                            case classLoader.MotionEvent.ACTION_DOWN.value: initialX = view.getX() - event.getRawX(); initialY = view.getY() - event.getRawY(); isMove = false; initialTouchTime = Date.now(); break;
                            case classLoader.MotionEvent.ACTION_UP.value:
                                if (!isMove) {
                                    if (!isMenuLayout) {
                                        const currentY = mainLayout.getY(), targetY = (currentY + menuHeight / 2) - menuStart.getHeight() / 1.5;
                                        mainLayout.removeView(menuStart); mainLayout.addView(menuLayout); mainLayout.setY(targetY); isMenuLayout = true;
                                    } else {
                                        const currentY = mainLayout.getY(), targetY = (currentY - menuHeight / 2) + menuStart.getHeight() / 1.5;
                                        mainLayout.removeView(menuLayout); mainLayout.addView(menuStart); mainLayout.setY(targetY); isMenuLayout = false;
                                    }
                                }
                                break;
                            case classLoader.MotionEvent.ACTION_MOVE.value: view.setX(event.getRawX() + initialX); view.setY(event.getRawY() + initialY); if (Date.now() - initialTouchTime > 200) isMove = true; break;
                            default: return false;
                        }
                        return true;
                    }
                }
            })
            this.#mainLayout.setOnTouchListener(MainLayoutOnTouchListener.$new())
        }

        start() {
            this.#drawContentView(); this.#drawMainLayout(); this.#drawMenuStart(); this.#buildExpandedMenu(); this.#createMainLayoutEvent();
        }
    }

    let menu = null;
    const activeplayer = Module.findExportByName("libqplay.so", "dkCHgaGRiF").readPointer();
    const getlocaly = new NativeFunction(Module.findExportByName("libqplay.so", "_ZNK10W6NzgawMJy10qCgWga1ADREv"), "double", ["pointer"]);
    const getlocalx = new NativeFunction(Module.findExportByName("libqplay.so", "_ZNK10W6NzgawMJy10Qi2VgaCyrREv"), "double", ["pointer"]);
    const putExplosion = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10zF9VgaBKxR10tMaombuGXrEdddii"), "void", ["pointer", "double", "double", "double", "int", "int"]);
    let hurtPlayer = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10W6NzgawMJy10iPzUgaQKcQEdddRK10C8THgaTQxFP10MpGzgariDy"), "void", ["pointer", "double", "double", "double", "pointer", "pointer"]);
    const setVarValue = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10G0gxgajWBw10gVHMMaRyAEERK10C8THgaTQxF"), "void", ["pointer", "pointer"]);

    // Variáveis de controle das funções
    let canExplode = false, explosionsInterval = null, unhit = false, wallhack = false, autoOFF = false, showAdmins = false;
    let explosionSize = 80;
    let entityScannerInterval = null;
    let scanRadius = 1024; // Valor inicial do raio de busca em bytes

    const alpha = createTString('alpha=0.5');
    const zoom = createTString('zoom=1');

    function getPlayerProperties(p) {
        return {
            "alpha": Memory.readFloat(ptr(p.toInt32() + 356)), "zoom": Memory.readFloat(p.add(0x138)), "x": Memory.readDouble(p.add(0x238)), "y": Memory.readDouble(p.add(0x240)), "nick": readTString(ptr(p.toInt32() + 464)), "account": readTString(ptr(p.toInt32() + 696))
        };
    }

    Interceptor.attach(Module.findExportByName("libqplay.so", "_ZN10zF9VgaBKxR10CGk7IaA0MzEddb"), {
        'onLeave': function(ret) { if (wallhack) ret.replace(0); }
    });

    Interceptor.attach(Module.findExportByName("libqplay.so", "_ZN10MpGzgariDy10Q3v7IaUAWzERK10C8THgaTQxF"), {
        'onEnter': function(args) {
            if (autoOFF && args[0].toInt32() != activeplayer.toInt32() && menu != null) {
                menu.turnOffAllOptions();
                showToast("Jogador apareceu. Funções desativadas.");
            }
            if (!showAdmins) return;
            const playerPtr = args[0];
            const accRgx = /^(pc\:|graal\d+|guest.*)/;
            const props = getPlayerProperties(playerPtr);
            if (props.alpha < 0.5) setVarValue(playerPtr, alpha);
            if (props.zoom < 1) setVarValue(playerPtr, zoom);
            if (!props.account) return;
            const account = props.account.toLowerCase();
            if (account === '') return;
            if (!accRgx.test(account)) {
                showToast('Admin: ' + props.nick);
            }
        }
    });

    Interceptor.replace(Module.findExportByName("libqplay.so", "_ZN10W6NzgawMJy10iPzUgaQKcQEdddRK10C8THgaTQxFP10MpGzgariDy"), new NativeCallback((a, b, c, d, e, f) => {
        if (unhit) return 0;
        hurtPlayer(a, b, c, d, e, f);
    }, "void", ["pointer", "double", "double", "double", "pointer", "pointer"]));

    function makeExplosion(level) {
        if (!level) return;
        const playerX = getlocalx(activeplayer), playerY = getlocaly(activeplayer);
        const radius = explosionSize;
        const offset = radius / 2;
        for (let i = 0; i < radius; i++) {
            for (let j = 0; j < radius; j++) {
                putExplosion(level, playerX + offset - i, playerY + offset - j, 1, 0, 1);
            }
        }
    }

    Interceptor.attach(Module.findExportByName("libqplay.so", "_ZN10zF9VgaBKxR10iUxUgaX7aQEdd"), {
        onEnter: function(args) {
            if (!canExplode) return;
            canExplode = false;
            makeExplosion(args[0]);
        }
    });

    // =========================================================================================
    // == INÍCIO DA LÓGICA DO AUTO-EXPLORER DE ENTIDADES =======================================
    // =========================================================================================

    function autoScanEntities() {
        if (activeplayer.isNull()) return;

        let foundEntities = [];
        let processedPtrs = new Set(); // Para evitar entidades duplicadas na lista
        
        const playerX = getlocalx(activeplayer);
        const playerY = getlocaly(activeplayer);
        
        // Define a distância máxima em "unidades do jogo" para uma entidade ser considerada válida
        const maxDistance = 100.0; 

        // Itera para frente e para trás do jogador, dentro do raio de busca definido
        for (let offset = -scanRadius; offset <= scanRadius; offset += 4) { // Pula de 4 em 4 bytes (tamanho de um ponteiro)
            try {
                const currentAddress = activeplayer.add(offset);
                const potentialEntityPtr = currentAddress.readPointer();

                // Pula se o ponteiro for nulo, inválido ou já tiver sido processado
                if (potentialEntityPtr.isNull() || processedPtrs.has(potentialEntityPtr.toString())) {
                    continue;
                }
                
                // --- HEURÍSTICA 1: Tenta ler as coordenadas ---
                const entityX = potentialEntityPtr.add(0x238).readDouble();
                const entityY = potentialEntityPtr.add(0x240).readDouble();

                // --- HEURÍSTICA 2: Verifica se as coordenadas são válidas e próximas ---
                const distance = Math.sqrt(Math.pow(playerX - entityX, 2) + Math.pow(playerY - entityY, 2));
                if (isNaN(distance) || distance > maxDistance) {
                    continue; // Descarta se for NaN ou muito longe
                }

                // Se passou nos testes, é uma entidade provável!
                processedPtrs.add(potentialEntityPtr.toString());

                // --- HEURÍSTICA 3: Tenta ler o nome para ter mais informações ---
                let entityNick = "N/A";
                try {
                     const nick = readTString(potentialEntityPtr.add(464)); // 464 = 0x1D0
                     if (nick && nick.length > 0) {
                         entityNick = nick;
                     }
                } catch(e) { /* falha ao ler o nome é normal */ }
               
                // Formata o texto para exibição
                const displayText = `[${potentialEntityPtr}]\n  Nick: ${entityNick}\n  Pos: (${entityX.toFixed(2)}, ${entityY.toFixed(2)})`;
                foundEntities.push(displayText);

            } catch (e) {
                // Erros de leitura de memória são esperados. Apenas ignora e continua a busca.
            }
        }
        
        // Atualiza a interface do menu com a lista de entidades encontradas
        if (menu) {
            menu.updateEntityListUI(foundEntities);
        }
    }

    // =========================================================================================
    // == FIM DA LÓGICA DO AUTO-EXPLORER =======================================================
    // =========================================================================================


    const call_autoFarm = {
        on() { if (!explosionsInterval) explosionsInterval = setInterval(() => { canExplode = true }, 1000) },
        off() { if (explosionsInterval) { clearInterval(explosionsInterval); explosionsInterval = null; canExplode = false; } }
    };
    let afkInterval = null;
    const call_antiAfk = {
        on() { if (!afkInterval) afkInterval = setInterval(click, 240 * 1000) },
        off() { if (afkInterval) { clearInterval(afkInterval); afkInterval = null; } }
    };
    const call_unhit = { on() { unhit = true }, off() { unhit = false } };
    const call_autoOFF = { on() { autoOFF = true }, off() { autoOFF = false } };
    const call_wallhack = { on() { wallhack = true }, off() { wallhack = false } };
    const call_showAdmins = { on() { showAdmins = true }, off() { showAdmins = false } };

    const call_entityScanner = {
        on() {
            if (!entityScannerInterval) {
                autoScanEntities(); // Roda uma vez imediatamente ao ativar
                entityScannerInterval = setInterval(autoScanEntities, 2000); // Depois atualiza a cada 2 segundos
            }
        },
        off() {
            if (entityScannerInterval) {
                clearInterval(entityScannerInterval);
                entityScannerInterval = null;
                if (menu) menu.updateEntityListUI([]); // Limpa a lista ao desativar
            }
        }
    };

    Java.perform(function() {
        Java.scheduleOnMainThread(function() {
            const classLoader = getClassLoader(), mainActivity = getMainActivity(classLoader);
            menu = new Menu(classLoader, mainActivity)
            menu.createMenuStart("MENU", 15, "#006400")
            menu.createMenuLayout("#18122B", 420, 300) // Largura e Altura do menu
            menu.createMenuBarLayout("#635985")
            menu.createMenuBarTitle("EngModMobile", "#FFC107")
            menu.createMenuOptionsLayout("#443C68", "#393053")

            menu.addOption("autoFarm", "Auto Farm", call_autoFarm)

            menu.addSeekBar("Raio da Explosão:", explosionSize, 10, 150, function(value, type) {
                explosionSize = value;
                if (type === 'end') {
                    showToast(`Raio da explosão definido para ${value}x${value}.`, 0);
                }
            });

            menu.addOption("unhit", "Unhit (God Mode)", call_unhit)
            menu.addOption("wallhack", "Wallhack", call_wallhack)
            menu.addText("--- Utilitários ---", 12, "#FFFFFF")
            menu.addOption("showAdmins", "Show Admins", call_showAdmins)
            menu.addOption("autoOFF", "Auto Off", call_autoOFF)
            menu.addOption("antiAfk", "Anti AFK", call_antiAfk)

            menu.addText("--- Testes ---", 12, "#FFC107")
            menu.addOption("entityScanner", "Auto-Explorer Entidades", call_entityScanner)

            // NOVA SEEKBAR PARA CONTROLAR O RAIO DA BUSCA
            menu.addSeekBar("Raio da Busca (bytes):", scanRadius, 256, 8192, function(value, type) {
                 scanRadius = value;
                 if (type === 'end') {
                     showToast(`Raio de busca definido para ${value} bytes.`, 0);
                 }
            });

            menu.start()
        })
    })

    function getFunc(lib, func, type, params) { return new NativeFunction(Module.findExportByName(lib, func), type, params); }

    function createTString(str) {
        var str_pointer = malloc(4), str_struct = malloc(str.length + 8);
        str_pointer.writePointer(str_struct);
        str_struct.writeInt(str.length);
        ptr(parseInt(str_struct) + 4).writeInt(1);
        ptr(parseInt(str_struct) + 8).writeUtf8String(str);
        return str_pointer;
    }

    function readTString(str) {
        if (str && !str.isNull()) {
            var pstr = str.readPointer();
            if (pstr && !pstr.isNull()) {
                var strlen = pstr.readInt();
                if (strlen > 0) return ptr(parseInt(pstr) + 8).readCString(strlen);
            }
        }
        return null;
    }

    function click() {
        Java.perform(() => Java.scheduleOnMainThread(() => {
            let time = Java.use("android.os.SystemClock").uptimeMillis(), event = Java.use("android.view.MotionEvent").obtain(time, time + 50, 0, 500, 500, 0);
            getMainActivity(getClassLoader()).dispatchTouchEvent(event);
            console.log("Anti-AFK click performed.");
        }));
    }

}, 5000)
