setTimeout(()=>{
// Função malloc para alocar memória nativa (libc)
var malloc = getFunc("libc.so", "malloc", "pointer", ["int"])

// Função que carrega classes Android usadas para construir a interface e capturar eventos
function getClassLoader() {
    const classLoader = {
        Gravity: Java.use("android.view.Gravity"),
        TextView: Java.use("android.widget.TextView"),
        LinearLayout: Java.use("android.widget.LinearLayout"),
        ViewGroup_LayoutParams: Java.use("android.view.ViewGroup$LayoutParams"),
        LinearLayout_LayoutParams: Java.use("android.widget.LinearLayout$LayoutParams"),
        Color: Java.use("android.graphics.Color"),
        ActivityThread: Java.use("android.app.ActivityThread"),
        ActivityThread_ActivityClientRecord: Java.use("android.app.ActivityThread$ActivityClientRecord"),
        View_OnTouchListener: Java.use("android.view.View$OnTouchListener"),
        MotionEvent: Java.use("android.view.MotionEvent"),
        String: Java.use("java.lang.String"),
        ScrollView: Java.use("android.widget.ScrollView"),
        View_OnClickListener: Java.use("android.view.View$OnClickListener"),
        SeekBar: Java.use("android.widget.SeekBar")
    }
    return classLoader
}

// Converte unidades dp em pixels para dimensionar corretamente na tela
function pixelDensityToPixels(context, dp) {
    const density = context.getResources().getDisplayMetrics().density.value
    return parseInt(dp * density)
}

// Obtém a activity principal em execução no app
function getMainActivity(classLoader) {
    const activityThread = classLoader.ActivityThread.sCurrentActivityThread.value
    const mActivities = activityThread.mActivities.value
    const activityClientRecord = Java.cast(mActivities.valueAt(0), classLoader.ActivityThread_ActivityClientRecord)
    return activityClientRecord.activity.value
}

// Exibe uma mensagem Toast curta na tela (Android)
function showToast(text, time = 1) {
  Java.perform(() => {
      Java.scheduleOnMainThread(function() {
          var toast = Java.use("android.widget.Toast");
          toast.makeText(Java.use("android.app.ActivityThread").currentApplication().getApplicationContext(),
                         Java.use("java.lang.String").$new(text), time).show();
      });
  });
}

// Classe que representa um menu na tela Android com opções e interatividade
class Menu {
    #classLoader
    #activity
    #MATCH_PARENT
    #WRAP_CONTENT
    #contentView
    #mainLayout
    #menuStart
    #menuLayout
    #menuBarLayout
    #menuBarTitle
    #menuScrollView
    #menuScrollLayout
    #options
    #colorOn
    #colorOff

    // Construtor cria a estrutura base para o menu
    constructor(classLoader, activity) {
        this.#classLoader = classLoader
        this.#activity = activity
        this.#MATCH_PARENT = classLoader.LinearLayout_LayoutParams.MATCH_PARENT.value
        this.#WRAP_CONTENT = classLoader.LinearLayout_LayoutParams.WRAP_CONTENT.value
        this.#options = {}
        this.#createContentView()
        this.#createMainLayout()
        this.#createMenuScroll()
    }

    // Cria o layout raiz transparente e centralizado para conter o menu
    #createContentView() {
        this.#contentView = this.#classLoader.LinearLayout.$new(this.#activity)
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#MATCH_PARENT)
        this.#contentView.setLayoutParams(params)
        this.#contentView.setGravity(this.#classLoader.Gravity.CENTER.value)
        this.#contentView.setBackgroundColor(this.#classLoader.Color.TRANSPARENT.value)
    }

    // Cria o layout principal do menu (com tamanho que envolve seu conteúdo)
    #createMainLayout() {
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
        this.#mainLayout = this.#classLoader.LinearLayout.$new(this.#activity)
        this.#mainLayout.setLayoutParams(params)
    }

    // Cria uma ScrollView para abrigar opções do menu e configura padding
    #createMenuScroll() {
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT)
        this.#menuScrollView = this.#classLoader.ScrollView.$new(this.#activity)
        const padding = pixelDensityToPixels(this.#activity, 8)
        this.#menuScrollView.setLayoutParams(params)
        this.#menuScrollView.setPadding(padding, padding, padding, padding)
        this.#menuScrollView.mFillViewport.value = true
    }

    // Cria layout vertical dentro da ScrollView que receberá as opções
    #createMenuScrollLayout() {
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT)
        this.#menuScrollLayout = this.#classLoader.LinearLayout.$new(this.#activity)
        this.#menuScrollLayout.setLayoutParams(params)
        this.#menuScrollLayout.setOrientation(this.#menuScrollLayout.VERTICAL.value)
    }

    // Configura as cores dos estados ligado e desligado das opções
    createMenuOptionsLayout(colorOn, colorOff) {
        this.#createMenuScroll()
        this.#createMenuScrollLayout()
        this.#colorOn = colorOn
        this.#colorOff = colorOff
    }

    // Cria o botão inicial (minimizado) do menu, com título, tamanho e cor
    createMenuStart(title, size, color) {
        size = pixelDensityToPixels(this.#activity, size)
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
        this.#menuStart = this.#classLoader.TextView.$new(this.#activity)
        this.#menuStart.setLayoutParams(params)
        this.#menuStart.setText(this.#classLoader.String.$new(title))
        this.#menuStart.setTextSize(size)
        this.#menuStart.setTextColor(this.#classLoader.Color.parseColor(color))
        this.#menuStart.setBackgroundColor(this.#classLoader.Color.WHITE.value)
    }

    // Cria o layout expandido do menu, com tamanho e cor definidos
    createMenuLayout(color, size) {
        const sizePx = pixelDensityToPixels(this.#activity, size)
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(sizePx, sizePx)
        this.#menuLayout = this.#classLoader.LinearLayout.$new(this.#activity)
        this.#menuLayout.setLayoutParams(params)
        this.#menuLayout.setBackgroundColor(this.#classLoader.Color.parseColor(color))
        this.#menuLayout.setOrientation(this.#menuLayout.VERTICAL.value)
    }

    // Cria a barra superior do menu com cor e padding
    createMenuBarLayout(color) {
        const padding = pixelDensityToPixels(this.#activity, 10)
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT)
        this.#menuBarLayout = this.#classLoader.LinearLayout.$new(this.#activity)
        this.#menuBarLayout.setLayoutParams(params)
        this.#menuBarLayout.setBackgroundColor(this.#classLoader.Color.parseColor(color))
        this.#menuBarLayout.setPadding(padding, padding, 0, padding)
    }

    // Define título para barra do menu com texto e cor personalizada
    createMenuBarTitle(title, color) {
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
        this.#menuBarTitle = this.#classLoader.TextView.$new(this.#activity)
        this.#menuBarTitle.setLayoutParams(params)
        this.#menuBarTitle.setText(this.#classLoader.String.$new(title))
        this.#menuBarTitle.setTextColor(this.#classLoader.Color.parseColor(color))
    }

    // Adiciona o layout raiz contendo o menu na activity para ele aparecer na tela
    #drawContentView() {
        this.#activity.addContentView(this.#contentView, this.#contentView.getLayoutParams())
    }

    // Adiciona o layout principal dentro do container raiz
    #drawMainLayout() {
        this.#contentView.addView(this.#mainLayout)
    }

    // Adiciona o botão minimizado do menu no layout principal
    #drawMenuStart() {
        this.#mainLayout.addView(this.#menuStart)
    }

    // Adiciona o layout expandido do menu no layout principal
    #drawMenuLayout() {
        this.#mainLayout.addView(this.#menuLayout)
    }

    // Adiciona a barra do menu no layout expandido
    #drawMenuBarLayout() {
        this.#menuLayout.addView(this.#menuBarLayout)
    }

    // Adiciona o título na barra do menu
    #drawMenuBarTitle() {
        this.#menuBarLayout.addView(this.#menuBarTitle)
    }

    // Adiciona as opções do menu no scroll layout, dentro do menu expandido
    #drawMenuOptions() {
        this.#menuLayout.addView(this.#menuScrollView)
        this.#menuScrollView.addView(this.#menuScrollLayout)
    }

    // Cria listener do clique em cada opção, alternando visual e chamando callbacks on/off
    #createOptionClickEvent(id, optionView, callbacks) {
        const classLoader = this.#classLoader
        let optionState = false // Estado ligado/desligado da opção
        const colorOn = this.#colorOn
        const colorOff = this.#colorOff
        const optionOnClickListener = Java.registerClass({
            name: "com.example." + id,
            implements: [classLoader.View_OnClickListener],
            methods: {
                onClick(p1) {
                    if (!optionState) {
                        p1.setBackgroundColor(classLoader.Color.parseColor(colorOn))
                        optionState = true
                        callbacks.on()
                    } else {
                        p1.setBackgroundColor(classLoader.Color.parseColor(colorOff))
                        optionState = false
                        callbacks.off()
                    }
                }
            }
        })
        optionView.setOnClickListener(optionOnClickListener.$new())
    }

    // Adiciona uma nova opção ao menu com id, nome e callbacks para ativar/desativar
    addOption(id, name, callbacks) {
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT);
        const padding = pixelDensityToPixels(this.#activity, 5);
        const margin = pixelDensityToPixels(this.#activity, 10);
        const option = this.#classLoader.TextView.$new(this.#activity);

        option.setText(this.#classLoader.String.$new(name));
        option.setBackgroundColor(this.#classLoader.Color.parseColor(this.#colorOff)); // cor apagada inicialmente
        option.setTextColor(this.#classLoader.Color.parseColor("#75757B"));
        params.setMargins(0, 0, 0, margin);
        option.setLayoutParams(params);
        option.setPadding(padding, padding, 0, padding);

        this.#menuScrollLayout.addView(option);
        this.#createOptionClickEvent(id, option, callbacks);
        this.#options[id] = { callbacks, optionView: option };
    }

    // Desliga todas as opções visuais e chama callbacks off
    turnOffAllOptions() {
        for (const id in this.#options) {
            const { callbacks, optionView } = this.#options[id];
            optionView.setBackgroundColor(this.#classLoader.Color.parseColor(this.#colorOff));
            callbacks.off();
        }
    }

    // Adiciona um texto customizado no menu
    addText(text, textSize, textColor) {
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT);
        const margin = pixelDensityToPixels(this.#activity, 5);
        const textView = this.#classLoader.TextView.$new(this.#activity);

        textView.setText(this.#classLoader.String.$new(text));
        textView.setTextSize(textSize);
        textView.setTextColor(this.#classLoader.Color.parseColor(textColor));
        params.setMargins(0, 0, 0, margin);
        textView.setLayoutParams(params);

        this.#menuScrollLayout.addView(textView);
    }

    // Adiciona um seekbar (slider) com label e callbacks de evento
    addSeekBar(textValue, initialValue, minValue, maxValue, callback) {
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT);
        const margin = pixelDensityToPixels(this.#activity, 1);
        const seekBar = this.#classLoader.SeekBar.$new(this.#activity, null, 0, Java.use("android.R$style").Widget_Holo_SeekBar.value);
        const textView = this.#classLoader.TextView.$new(this.#activity);

        seekBar.setMax(maxValue - minValue);
        seekBar.setProgress(0);
        params.setMargins(0, 0, 0, margin);
        seekBar.setLayoutParams(params);

        const text = Java.use("java.lang.String").$new(textValue + " " + initialValue);
        textView.setText(text);
        textView.setTextColor(this.#classLoader.Color.parseColor("#75757B"));
        seekBar.setProgress(initialValue);

        const SeekBarChangeListener = Java.use("android.widget.SeekBar$OnSeekBarChangeListener");
        const SeekBarChangeListenerImplementation = Java.registerClass({
            name: "com.example.SeekBarChangeListener" + Math.floor(Math.random() * 1000),
            implements: [SeekBarChangeListener],
            methods: {
                onProgressChanged(seekBar, progress, fromUser) {
                    const value = progress + minValue;
                    const text = Java.use("java.lang.String").$new(textValue + " " + value);
                    textView.setText(text);
                    callback(value, "move");
                },
                onStartTrackingTouch(seekBar) {
                    const progress = seekBar.getProgress();
                    const value = progress + minValue;
                    const text = Java.use("java.lang.String").$new(textValue + " " + value);
                    textView.setText(text);
                    callback(value, "start");
                },
                onStopTrackingTouch(seekBar) {
                    const progress = seekBar.getProgress();
                    const value = progress + minValue;
                    const text = Java.use("java.lang.String").$new(textValue + " " + value);
                    textView.setText(text);
                    callback(value, "end");
                }
            }
        });

        seekBar.setOnSeekBarChangeListener(SeekBarChangeListenerImplementation.$new());
        this.#menuScrollLayout.addView(textView);
        this.#menuScrollLayout.addView(seekBar);

        textView.setLayoutParams(params);
        textView.setGravity(this.#classLoader.Gravity.CENTER.value);
    }

    // Listener de toque para permitir mover o menu e alternar entre minimizado e expandido
    #createMainLayoutEvent() {
        const mainLayout = this.#mainLayout;
        const menuLayout = this.#menuLayout;
        const menuStart = this.#menuStart;
        const classLoader = this.#classLoader;
        let initialX = 0;
        let initialY = 0;
        let isMove = false;
        let isMenuLayout = false;
        let initialTouchTime = 0;
        const MainLayoutOnTouchListener = Java.registerClass({
            name: "com.example.MainLayoutEvent",
            implements: [classLoader.View_OnTouchListener],
            methods: {
                onTouch(view, event) {
                    const menuHeight = menuLayout.getHeight();
                    switch (event.getAction()) {
                        case classLoader.MotionEvent.ACTION_DOWN.value:
                            initialX = view.getX() - event.getRawX();
                            initialY = view.getY() - event.getRawY();
                            isMove = false;
                            initialTouchTime = Date.now();
                            break;
                        case classLoader.MotionEvent.ACTION_UP.value:
                            if (!isMove) {
                                if (!isMenuLayout) {
                                    const currentY = mainLayout.getY();
                                    const targetY = (currentY + menuHeight / 2) - menuStart.getHeight() / 1.5;
                                    mainLayout.removeView(menuStart);
                                    mainLayout.addView(menuLayout);
                                    mainLayout.setY(targetY);
                                    isMenuLayout = true;
                                } else {
                                    const currentY = mainLayout.getY();
                                    const targetY = (currentY - menuHeight / 2) + menuStart.getHeight() / 1.5;
                                    mainLayout.removeView(menuLayout);
                                    mainLayout.addView(menuStart);
                                    mainLayout.setY(targetY);
                                    isMenuLayout = false;
                                }
                            }
                            break;
                        case classLoader.MotionEvent.ACTION_MOVE.value:
                            view.setX(event.getRawX() + initialX);
                            view.setY(event.getRawY() + initialY);
                            let deltaTime = Date.now() - initialTouchTime;
                            if (deltaTime > 200) isMove = true;
                            break;
                        default:
                            return false;
                    }
                    return true;
                }
            }
        });
        this.#mainLayout.setOnTouchListener(MainLayoutOnTouchListener.$new());
    }

    // Inicia o menu exibindo-o completo
    start() {
        this.#drawContentView();
        this.#drawMainLayout();
        this.#drawMenuStart();
        this.#drawMenuBarLayout();
        this.#drawMenuBarTitle();
        this.#drawMenuOptions();
        this.#createMainLayoutEvent();
    }
}

// Cria uma segunda instância da classe Menu para janela idêntica vazia ao lado da principal
class SecondMenu {
    #classLoader
    #activity
    #MATCH_PARENT
    #WRAP_CONTENT
    #contentView
    #mainLayout
    #menuStart
    #menuLayout
    #menuBarLayout
    #menuBarTitle

    // Mesmo construtor da classe Menu mas não cria opções
    constructor(classLoader, activity) {
        this.#classLoader = classLoader
        this.#activity = activity
        this.#MATCH_PARENT = classLoader.LinearLayout_LayoutParams.MATCH_PARENT.value
        this.#WRAP_CONTENT = classLoader.LinearLayout_LayoutParams.WRAP_CONTENT.value
        this.#createContentView()
        this.#createMainLayout()
    }

    #createContentView() {
        this.#contentView = this.#classLoader.LinearLayout.$new(this.#activity)
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#MATCH_PARENT)
        this.#contentView.setLayoutParams(params)
        this.#contentView.setGravity(this.#classLoader.Gravity.CENTER.value)
        this.#contentView.setBackgroundColor(this.#classLoader.Color.TRANSPARENT.value)
    }

    #createMainLayout() {
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
        this.#mainLayout = this.#classLoader.LinearLayout.$new(this.#activity)
        this.#mainLayout.setLayoutParams(params)
    }

    createMenuStart(title, size, color) {
        size = pixelDensityToPixels(this.#activity, size)
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
        this.#menuStart = this.#classLoader.TextView.$new(this.#activity)
        this.#menuStart.setLayoutParams(params)
        this.#menuStart.setText(this.#classLoader.String.$new(title))
        this.#menuStart.setTextSize(size)
        this.#menuStart.setTextColor(this.#classLoader.Color.parseColor(color))
        this.#menuStart.setBackgroundColor(this.#classLoader.Color.WHITE.value)
    }

    createMenuLayout(color, size) {
        const sizePx = pixelDensityToPixels(this.#activity, size)
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(sizePx, sizePx)
        this.#menuLayout = this.#classLoader.LinearLayout.$new(this.#activity)
        this.#menuLayout.setLayoutParams(params)
        this.#menuLayout.setBackgroundColor(this.#classLoader.Color.parseColor(color))
        this.#menuLayout.setOrientation(this.#menuLayout.VERTICAL.value)
    }

    createMenuBarLayout(color) {
        const padding = pixelDensityToPixels(this.#activity, 10)
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT)
        this.#menuBarLayout = this.#classLoader.LinearLayout.$new(this.#activity)
        this.#menuBarLayout.setLayoutParams(params)
        this.#menuBarLayout.setBackgroundColor(this.#classLoader.Color.parseColor(color))
        this.#menuBarLayout.setPadding(padding, padding, 0, padding)
    }

    createMenuBarTitle(title, color) {
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
        this.#menuBarTitle = this.#classLoader.TextView.$new(this.#activity)
        this.#menuBarTitle.setLayoutParams(params)
        this.#menuBarTitle.setText(this.#classLoader.String.$new(title))
        this.#menuBarTitle.setTextColor(this.#classLoader.Color.parseColor(color))
    }

    #drawContentView() {
        this.#activity.addContentView(this.#contentView, this.#contentView.getLayoutParams())
    }

    #drawMainLayout() {
        this.#contentView.addView(this.#mainLayout)
    }

    #drawMenuStart() {
        this.#mainLayout.addView(this.#menuStart)
    }

    #drawMenuLayout() {
        this.#mainLayout.addView(this.#menuLayout)
    }

    #drawMenuBarLayout() {
        this.#menuLayout.addView(this.#menuBarLayout)
    }

    #drawMenuBarTitle() {
        this.#menuBarLayout.addView(this.#menuBarTitle)
    }

    start() {
        this.#drawContentView()
        this.#drawMainLayout()
        this.#drawMenuStart()
        this.#drawMenuBarLayout()
        this.#drawMenuBarTitle()
    }

    // Funções para esconder e mostrar o menu expandido / minimizado
    hideMenu() {
        this.#mainLayout.removeView(this.#menuLayout)
        this.#mainLayout.addView(this.#menuStart)
    }

    showMenu() {
        this.#mainLayout.removeView(this.#menuStart)
        this.#mainLayout.addView(this.#menuLayout)
    }
}

// Controla a visibilidade sincronizada entre os dois menus
class DualMenuController {
    constructor(primaryMenu, secondaryMenu) {
        this.primaryMenu = primaryMenu
        this.secondaryMenu = secondaryMenu
        this.isMenuExpanded = false
        this.setupToggleOnMenuClick()
    }

    // Alterna o estado do menu principal e secundário quando clicado o minimizado
    setupToggleOnMenuClick() {
        const classLoader = this.primaryMenu.#classLoader
        const primaryMinimized = this.primaryMenu.#menuStart
        const secondary = this.secondaryMenu

        const ToggleListener = Java.registerClass({
            name: "com.example.ToggleMenuListener",
            implements: [classLoader.View_OnClickListener],
            methods: {
                onClick(view) {
                    if (this.isMenuExpanded) {
                        this.isMenuExpanded = false
                        this.primaryMenu.hideMenu()
                        this.secondaryMenu.hideMenu()
                    } else {
                        this.isMenuExpanded = true
                        this.primaryMenu.showMenu()
                        this.secondaryMenu.showMenu()
                    }
                }
            }
        })

        // Rebind do contexto para capturar dentro da função
        const self = this
        const listenerInstance = ToggleListener.$new()
        listenerInstance.isMenuExpanded = false
        listenerInstance.primaryMenu = self.primaryMenu
        listenerInstance.secondaryMenu = self.secondaryMenu
        listenerInstance.onClick = function(view) {
            this.isMenuExpanded = !this.isMenuExpanded
            if (this.isMenuExpanded) {
                this.primaryMenu.showMenu()
                this.secondaryMenu.showMenu()
            } else {
                this.primaryMenu.hideMenu()
                this.secondaryMenu.hideMenu()
            }
        }

        primaryMinimized.setOnClickListener(listenerInstance)
    }

    start() {
        this.primaryMenu.start()
        this.secondaryMenu.start()
        this.secondaryMenu.hideMenu()  // inicia com menu secundário minimizado
    }
}


// Instancia o menu principal e o secundário idêntico vazio e controla a visibilidade
Java.perform(function() {
    Java.scheduleOnMainThread(function() {
        const classLoader = getClassLoader()
        const mainActivity = getMainActivity(classLoader)

        // Cria menu principal com opções
        const primaryMenu = new Menu(classLoader, mainActivity)
        primaryMenu.createMenuStart("MENU", 15, "#006400")
        primaryMenu.createMenuLayout("#18122B", 180)
        primaryMenu.createMenuBarLayout("#635985")
        primaryMenu.createMenuBarTitle("EngModMobile", "#FFC107")
        primaryMenu.createMenuOptionsLayout("#443C68", "#393053")
        primaryMenu.addOption("antiAfk","Anti AFK",call_antiAfk)
        primaryMenu.addOption("autoOFF", "auto Off", call_autoOFF)
        primaryMenu.addOption("showAdmins", "Show admins", call_showAdmins)
        primaryMenu.addOption("autoFarm", "Auto Farm", call_autoFarm)
        primaryMenu.addOption("unhit", "unhit", call_unhit)
        primaryMenu.addOption("wallhack", "Wallhack", call_wallhack)

        // Cria menu secundário idêntico, porém vazio (sem opções)
        const secondaryMenu = new SecondMenu(classLoader, mainActivity)
        secondaryMenu.createMenuStart("MENU 2", 15, "#006400")
        secondaryMenu.createMenuLayout("#18122B", 180)
        secondaryMenu.createMenuBarLayout("#635985")
        secondaryMenu.createMenuBarTitle("EngModMobile 2", "#FFC107")

        // Controla alternância sincronizada dos menus
        const controller = new DualMenuController(primaryMenu, secondaryMenu)
        controller.start()
    })
})

// Reaproveitando os objetos de callback globalmente:
const call_showAdmins = {
    on() { showAdmins = true },
    off() { showAdmins = false }
}

const call_autoFarm = {
    on() {
        if (!explosionsInterval) {
            explosionsInterval = setInterval(() => { canExplode = true },1000)
        }
    },
    off() {
        if (explosionsInterval != null) {
            clearInterval(explosionsInterval)
            explosionsInterval = null
            canExplode = false
        }
    }
}

let afkInterval = null
const call_antiAfk = {
    on() {
        if (!afkInterval) {
            afkInterval = setInterval(click,240*1000)
        }
    },
    off() {
        if (afkInterval != null) {
            clearInterval(afkInterval)
            afkInterval = null
        }
    }
}

const call_unhit = {
    on() { unhit = true },
    off() { unhit = false }
}

const call_autoOFF = {
    on() { autoOFF = true },
    off() { autoOFF = false }
}

const call_wallhack = {
    on() { wallhack = true },
    off() { wallhack = false }
}
  
// Inicia o menu e configura na thread principal Android
Java.perform(function () {
    Java.scheduleOnMainThread(function () {
        const classLoader = getClassLoader()
        const mainActivity = getMainActivity(classLoader)
        menu = new Menu(classLoader, mainActivity)
        menu.createMenuStart("MENU", 15, "#006400")
        menu.createMenuLayout("#18122B", 180)
        menu.createMenuBarLayout("#635985")
        menu.createMenuBarTitle("EngModMobile", "#FFC107")
        menu.createMenuOptionsLayout("#443C68", "#393053")
        menu.addOption("antiAfk", "Anti AFK", call_antiAfk)
        menu.addOption("autoOFF", "auto Off", call_autoOFF)
        menu.addOption("showAdmins", "Show admins", call_showAdmins)
        menu.addOption("autoFarm", "Auto Farm", call_autoFarm)
        menu.addOption("unhit", "unhit", call_unhit)
        menu.addOption("wallhack", "Wallhack", call_wallhack)
        menu.start()
    })
})

// Função para criar ponteiros para funções nativas na lib escolhida
function getFunc(lib, func, type, params) {
    return new NativeFunction(Module.findExportByName(lib, func), type, params);
}

// Monta uma string na estrutura interna usada pelas funções nativas do jogo
function createTString(str) {
    var str_pointer = malloc(4)
    var str_struct = malloc(str.length + 8)
    str_pointer.writePointer(str_struct)
    str_struct.writeInt(str.length)
    ptr(parseInt(str_struct) + 4).writeInt(1)
    ptr(parseInt(str_struct) + 8).writeUtf8String(str)
    return str_pointer
}

// Faz a leitura da string armazenada na estrutura interna do jogo
function readTString(str) {
    if (!str.isNull()) {
        if (parseInt(str) != 0) {
            var pstr = str.readPointer()
            if (!pstr.isNull()) {
                var strlen = pstr.readInt()
                if (strlen > 0) {
                    var strStart = parseInt(pstr) + 8
                    return ptr(strStart).readCString(strlen)
                }
            }
        }
    }
}

// Dispara um click "simulado" para evitar desconexão por inatividade (anti-AFK)
function click() {
    Java.perform(function () {
        Java.scheduleOnMainThread(function () {
            let timer7 = Java.use("android.os.SystemClock").uptimeMillis();
            let motionEvent = Java.use("android.view.MotionEvent").obtain(
                timer7,
                (timer7 + 50),
                Java.use("android.view.MotionEvent").ACTION_DOWN.value,
                1915,
                1945,
                0
            );
            getMainActivity(getClassLoader()).dispatchTouchEvent(motionEvent);
            console.log("clicked")
        });
    });
}


}, 5000)
