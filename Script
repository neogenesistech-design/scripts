setTimeout(() => {
    var malloc = getFunc("libc.so", "malloc", "pointer", ["int"])
    let currentToast = null;

    function getClassLoader() {
        return {
            Gravity: Java.use("android.view.Gravity"),
            TextView: Java.use("android.widget.TextView"),
            LinearLayout: Java.use("android.widget.LinearLayout"),
            ViewGroup_LayoutParams: Java.use("android.view.ViewGroup$LayoutParams"),
            LinearLayout_LayoutParams: Java.use("android.widget.LinearLayout$LayoutParams"),
            Color: Java.use("android.graphics.Color"),
            ActivityThread: Java.use("android.app.ActivityThread"),
            View_OnTouchListener: Java.use("android.view.View$OnTouchListener"),
            MotionEvent: Java.use("android.view.MotionEvent"),
            String: Java.use("java.lang.String"),
            ScrollView: Java.use("android.widget.ScrollView"),
            View_OnClickListener: Java.use("android.view.View$OnClickListener"),
            SeekBar: Java.use("android.widget.SeekBar")
        };
    }

    function pixelDensityToPixels(context, dp) {
        const density = context.getResources().getDisplayMetrics().density.value;
        return parseInt(dp * density);
    }

    function getMainActivity(classLoader) {
        const activityThread = classLoader.ActivityThread.sCurrentActivityThread.value;
        const mActivities = activityThread.mActivities.value;
        const records = mActivities.values().iterator();
        while (records.hasNext()) {
            const record = records.next();
            if (!record.activity.value.isFinishing()) {
                return record.activity.value;
            }
        }
        return null;
    }

    function showToast(text, time = 1) {
        Java.perform(() => {
            Java.scheduleOnMainThread(function() {
                if (currentToast) {
                    currentToast.cancel();
                }
                var toast = Java.use("android.widget.Toast");
                var newToast = toast.makeText(Java.use("android.app.ActivityThread").currentApplication().getApplicationContext(),
                    Java.use("java.lang.String").$new(text), time);
                newToast.show();
                currentToast = newToast;
            });
        });
    }

    class Menu {
        #classLoader; #activity; #MATCH_PARENT; #WRAP_CONTENT; #contentView; #mainLayout; #menuStart; #menuLayout; #menuBarLayout; #menuBarTitle; #options; #colorOn; #colorOff;
        #panelsContainerLayout; #leftPanelLayout; #rightPanelLayout; #menuScrollView; #menuScrollLayout;
        #playerInfoLayout; // NOVO: Layout para informações do jogador

        constructor(classLoader, activity) {
            this.#classLoader = classLoader;
            this.#activity = activity;
            this.#MATCH_PARENT = classLoader.LinearLayout_LayoutParams.MATCH_PARENT.value;
            this.#WRAP_CONTENT = classLoader.LinearLayout_LayoutParams.WRAP_CONTENT.value;
            this.#options = {};
            this.#createContentView();
            this.#createMainLayout();
        }
        
        #createContentView() {
            this.#contentView = this.#classLoader.LinearLayout.$new(this.#activity);
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#MATCH_PARENT);
            this.#contentView.setLayoutParams(layoutParams);
            this.#contentView.setGravity(this.#classLoader.Gravity.CENTER.value);
            this.#contentView.setBackgroundColor(this.#classLoader.Color.TRANSPARENT.value);
        }

        #createMainLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT);
            this.#mainLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#mainLayout.setLayoutParams(layoutParams);
        }

        createMenuLayout(color, width, height) {
            const widthPx = pixelDensityToPixels(this.#activity, width);
            const heightPx = pixelDensityToPixels(this.#activity, height);
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(widthPx, heightPx);
            this.#menuLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#menuLayout.setLayoutParams(layoutParams);
            this.#menuLayout.setBackgroundColor(this.#classLoader.Color.parseColor(color));
            this.#menuLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
        }

        createMenuBarLayout(color) {
            const padding = pixelDensityToPixels(this.#activity, 10);
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT);
            this.#menuBarLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#menuBarLayout.setLayoutParams(layoutParams);
            this.#menuBarLayout.setBackgroundColor(this.#classLoader.Color.parseColor(color));
            this.#menuBarLayout.setPadding(padding, padding, 0, padding);
        }

        createMenuBarTitle(title, color) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT);
            this.#menuBarTitle = this.#classLoader.TextView.$new(this.#activity);
            this.#menuBarTitle.setLayoutParams(layoutParams);
            this.#menuBarTitle.setText(this.#classLoader.String.$new(title));
            this.#menuBarTitle.setTextColor(this.#classLoader.Color.parseColor(color));
        }

        #createPanelsContainerLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#MATCH_PARENT);
            this.#panelsContainerLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#panelsContainerLayout.setLayoutParams(layoutParams);
            this.#panelsContainerLayout.setOrientation(this.#classLoader.LinearLayout.HORIZONTAL.value);
        }

        #createLeftPanelLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(0, this.#MATCH_PARENT, 1.0);
            this.#leftPanelLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#leftPanelLayout.setLayoutParams(layoutParams);
            this.#leftPanelLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
        }
        
        // NOVO: Cria o painel direito para as informações do jogador
        #createRightPanelLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(0, this.#MATCH_PARENT, 1.2); // Um pouco mais largo
            const padding = pixelDensityToPixels(this.#activity, 8);
            this.#rightPanelLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#rightPanelLayout.setLayoutParams(layoutParams);
            this.#rightPanelLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
            this.#rightPanelLayout.setPadding(padding, padding, padding, padding);

            // Título do painel
            const infoTitle = this.#classLoader.TextView.$new(this.#activity);
            infoTitle.setText(this.#classLoader.String.$new("--- Player Info ---"));
            infoTitle.setTextColor(this.#classLoader.Color.parseColor("#FFC107"));
            infoTitle.setGravity(this.#classLoader.Gravity.CENTER.value);
            this.#rightPanelLayout.addView(infoTitle);

            // Layout que conterá as informações
            this.#playerInfoLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#playerInfoLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
            this.#rightPanelLayout.addView(this.#playerInfoLayout);
        }
        
        // NOVO: Atualiza as informações do jogador na UI
        updatePlayerInfo(playerProps) {
            Java.scheduleOnMainThread(() => {
                if (!this.#playerInfoLayout) return;
                this.#playerInfoLayout.removeAllViews(); // Limpa as informações antigas

                const createInfoTextView = (text) => {
                    const textView = this.#classLoader.TextView.$new(this.#activity);
                    textView.setText(this.#classLoader.String.$new(text));
                    textView.setTextColor(this.#classLoader.Color.parseColor("#EFEFEF"));
                    this.#playerInfoLayout.addView(textView);
                };

                createInfoTextView(`Nick: ${playerProps.nick || "N/A"}`);
                createInfoTextView(`Account: ${playerProps.account || "N/A"}`);
                createInfoTextView(`Pos X: ${playerProps.x.toFixed(2)}`);
                createInfoTextView(`Pos Y: ${playerProps.y.toFixed(2)}`);
            });
        }

        #createMenuScrollView() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#MATCH_PARENT);
            this.#menuScrollView = this.#classLoader.ScrollView.$new(this.#activity);
            const padding = pixelDensityToPixels(this.#activity, 8);
            this.#menuScrollView.setLayoutParams(layoutParams);
            this.#menuScrollView.setPadding(padding, padding, padding, padding);
        }

        #createMenuScrollLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT);
            this.#menuScrollLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#menuScrollLayout.setLayoutParams(layoutParams);
            this.#menuScrollLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
        }

        createMenuOptionsLayout(colorOn, colorOff) {
            this.#createMenuScrollView();
            this.#createMenuScrollLayout();
            this.#colorOn = colorOn;
            this.#colorOff = colorOff;
        }

        createMenuStart(title, size, color) {
            size = pixelDensityToPixels(this.#activity, size)
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
            this.#menuStart = this.#classLoader.TextView.$new(this.#activity)
            this.#menuStart.setLayoutParams(layoutParams)
            this.#menuStart.setText(this.#classLoader.String.$new(title))
            this.#menuStart.setTextSize(size)
            this.#menuStart.setTextColor(this.#classLoader.Color.parseColor(color))
            this.#menuStart.setBackgroundColor(this.#classLoader.Color.WHITE.value)
        }
        
        #drawContentView() { this.#activity.addContentView(this.#contentView, this.#contentView.getLayoutParams()) }
        #drawMainLayout() { this.#contentView.addView(this.#mainLayout) }
        #drawMenuStart() { this.#mainLayout.addView(this.#menuStart) }
        
        #buildExpandedMenu() {
            this.#menuBarLayout.addView(this.#menuBarTitle);
            this.#menuLayout.addView(this.#menuBarLayout);

            this.#createPanelsContainerLayout();
            this.#menuLayout.addView(this.#panelsContainerLayout);

            this.#createLeftPanelLayout();
            this.#menuScrollView.addView(this.#menuScrollLayout);
            this.#leftPanelLayout.addView(this.#menuScrollView);
            this.#panelsContainerLayout.addView(this.#leftPanelLayout);

            this.#createRightPanelLayout();
            this.#panelsContainerLayout.addView(this.#rightPanelLayout);
        }

        #createOptionClickEvent(id, optionView, callbacks, startsOn = false) {
            const classLoader = this.#classLoader;
            this.#options[id].state = startsOn; // Define o estado inicial

            const optionOnClickListener = Java.registerClass({
                name: "com.example." + id,
                implements: [classLoader.View_OnClickListener],
                methods: {
                    onClick: () => {
                        const option = this.#options[id];
                        option.state = !option.state; // Inverte o estado
                        if (option.state) {
                            option.optionView.setBackgroundColor(classLoader.Color.parseColor(this.#colorOn));
                            option.callbacks.on();
                        } else {
                            option.optionView.setBackgroundColor(classLoader.Color.parseColor(this.#colorOff));
                            option.callbacks.off();
                        }
                    }
                }
            });
            optionView.setOnClickListener(optionOnClickListener.$new());
        }

        addOption(id, name, callbacks, startsOn = false) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT);
            const padding = pixelDensityToPixels(this.#activity, 5);
            const option = this.#classLoader.TextView.$new(this.#activity);
            const margin = pixelDensityToPixels(this.#activity, 10);

            option.setText(this.#classLoader.String.$new(name));
            option.setTextColor(this.#classLoader.Color.parseColor("#EFEFEF"));
            layoutParams.setMargins(0, 0, 0, margin);
            option.setLayoutParams(layoutParams);
            option.setPadding(padding, padding, 0, padding);
            
            this.#options[id] = { callbacks, optionView: option, state: false };
            this.#createOptionClickEvent(id, option, callbacks, startsOn);
            
            if (startsOn) {
                option.setBackgroundColor(this.#classLoader.Color.parseColor(this.#colorOn));
                callbacks.on();
            } else {
                option.setBackgroundColor(this.#classLoader.Color.parseColor(this.#colorOff));
            }
            
            this.#menuScrollLayout.addView(option);
        }

        addText(text, textSize, textColor) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT);
            const margin = pixelDensityToPixels(this.#activity, 5);
            const textView = this.#classLoader.TextView.$new(this.#activity);
            textView.setText(this.#classLoader.String.$new(text));
            textView.setTextSize(textSize);
            textView.setTextColor(this.#classLoader.Color.parseColor(textColor));
            layoutParams.setMargins(0, 0, 0, margin);
            textView.setLayoutParams(layoutParams);
            this.#menuScrollLayout.addView(textView);
        }

        addSeekBar(textValue, initialValue, minValue, maxValue, callback) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT);
            const margin = pixelDensityToPixels(this.#activity, 1);
            const seekBar = this.#classLoader.SeekBar.$new(this.#activity, null, 0, Java.use("android.R$style").Widget_Holo_SeekBar.value);
            const textView = this.#classLoader.TextView.$new(this.#activity);
            
            seekBar.setMax(maxValue - minValue);
            seekBar.setProgress(initialValue - minValue);
            layoutParams.setMargins(0, 0, 0, margin);
            seekBar.setLayoutParams(layoutParams);
            
            const text = Java.use("java.lang.String").$new(textValue + " " + initialValue);
            textView.setText(text)
            textView.setTextColor(this.#classLoader.Color.parseColor("#EFEFEF"))

            const SeekBarChangeListener = Java.use("android.widget.SeekBar$OnSeekBarChangeListener");
            const SeekBarChangeListenerImplementation = Java.registerClass({
                name: "com.example.SeekBarChangeListener" + Math.random().toString(36).substring(2),
                implements: [SeekBarChangeListener],
                methods: {
                    onProgressChanged: (sb, progress, fromUser) => {
                        const value = progress + minValue;
                        const text = Java.use("java.lang.String").$new(textValue + " " + value);
                        textView.setText(text);
                        if (fromUser) callback(value, "move");
                    },
                    onStartTrackingTouch: (sb) => { callback(sb.getProgress() + minValue, "start"); },
                    onStopTrackingTouch: (sb) => { callback(sb.getProgress() + minValue, "end"); }
                }
            });
            seekBar.setOnSeekBarChangeListener(SeekBarChangeListenerImplementation.$new());
            
            this.#menuScrollLayout.addView(textView);
            this.#menuScrollLayout.addView(seekBar);
            textView.setLayoutParams(layoutParams);
            textView.setGravity(this.#classLoader.Gravity.CENTER.value);
        }

        #createMainLayoutEvent() {
            const mainLayout = this.#mainLayout, menuLayout = this.#menuLayout, menuStart = this.#menuStart, classLoader = this.#classLoader;
            let initialX = 0, initialY = 0, isMove = false, isMenuLayout = false, initialTouchTime = 0;
            const MainLayoutOnTouchListener = Java.registerClass({
                name: "com.example.MainLayoutEvent",
                implements: [classLoader.View_OnTouchListener],
                methods: {
                    onTouch(view, event) {
                        const menuHeight = menuLayout.getHeight();
                        switch (event.getAction()) {
                            case classLoader.MotionEvent.ACTION_DOWN.value: initialX = view.getX() - event.getRawX(); initialY = view.getY() - event.getRawY(); isMove = false; initialTouchTime = Date.now(); break;
                            case classLoader.MotionEvent.ACTION_UP.value:
                                if (!isMove) {
                                    if (!isMenuLayout) {
                                        const currentY = mainLayout.getY(), targetY = (currentY + menuHeight / 2) - menuStart.getHeight() / 1.5;
                                        mainLayout.removeView(menuStart); mainLayout.addView(menuLayout); mainLayout.setY(targetY); isMenuLayout = true;
                                    } else {
                                        const currentY = mainLayout.getY(), targetY = (currentY - menuHeight / 2) + menuStart.getHeight() / 1.5;
                                        mainLayout.removeView(menuLayout); mainLayout.addView(menuStart); mainLayout.setY(targetY); isMenuLayout = false;
                                    }
                                }
                                break;
                            case classLoader.MotionEvent.ACTION_MOVE.value: view.setX(event.getRawX() + initialX); view.setY(event.getRawY() + initialY); if (Date.now() - initialTouchTime > 200) isMove = true; break;
                            default: return false;
                        }
                        return true;
                    }
                }
            })
            this.#mainLayout.setOnTouchListener(MainLayoutOnTouchListener.$new())
        }
        
        start() {
            this.#drawContentView();
            this.#drawMainLayout();
            this.#drawMenuStart();
            this.#buildExpandedMenu();
            this.#createMainLayoutEvent();
        }
    }
    
    let menu = null;
    const activeplayer = Module.findExportByName("libqplay.so", "dkCHgaGRiF").readPointer();
    const getlocaly = new NativeFunction(Module.findExportByName("libqplay.so", "_ZNK10W6NzgawMJy10qCgWga1ADREv"), "double", ["pointer"]);
    const getlocalx = new NativeFunction(Module.findExportByName("libqplay.so", "_ZNK10W6NzgawMJy10Qi2VgaCyrREv"), "double", ["pointer"]);
    const putExplosion = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10zF9VgaBKxR10tMaombuGXrEdddii"), "void", ["pointer", "double", "double", "double", "int", "int"]);
    let hurtPlayer = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10W6NzgawMJy10iPzUgaQKcQEdddRK10C8THgaTQxFP10MpGzgariDy"), "void", ["pointer", "double", "double", "double", "pointer", "pointer"]);
    const setVarValue = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10G0gxgajWBw10gVHMMaRyAEERK10C8THgaTQxF"), "void", ["pointer", "pointer"]);

    let canExplode = false;
    let explosionsInterval = null;
    let unhit = false;
    let wallhack = false;
    let showAdmins = false; // Será ativado por padrão
    let autoOFF = false;
    let explosionSize = 80; // Valor padrão do raio

    const alpha = createTString('alpha=0.5');
    const zoom = createTString('zoom=1');

    function getPlayerProperties(p) {
        if (!p || p.isNull()) return {};
        return {
            "alpha": p.add(356).readFloat(),
            "zoom": p.add(0x138).readFloat(),
            "x": p.add(0x238).readDouble(),
            "y": p.add(0x240).readDouble(),
            "nick": readTString(p.add(464)),
            "account": readTString(p.add(696))
        };
    }

    Interceptor.attach(Module.findExportByName("libqplay.so", "_ZN10zF9VgaBKxR10CGk7IaA0MzEddb"), {
        'onLeave': function(ret) {
            if (wallhack) ret.replace(0);
        }
    });

    Interceptor.attach(Module.findExportByName("libqplay.so", "_ZN10MpGzgariDy10Q3v7IaUAWzERK10C8THgaTQxF"), {
        'onEnter': function(args) {
            const playerPtr = args[0];
            if (autoOFF && !playerPtr.equals(activeplayer) && menu != null) {
                menu.turnOffAllOptions();
                showToast("Player apareceu. Funções desativadas.");
            }
            if (!showAdmins) return;
            
            const accRgx = /^(pc\:|graal\d+|guest.*)/;
            const props = getPlayerProperties(playerPtr);
            if (props.alpha < 0.5) setVarValue(playerPtr, alpha);
            if (props.zoom < 1) setVarValue(playerPtr, zoom);
            if (!props.account) return;
            
            const account = props.account.toLowerCase();
            if (account === '') return;
            
            if (!accRgx.test(account)) {
                showToast('Admin: ' + props.nick);
            }
        }
    });

    Interceptor.replace(Module.findExportByName("libqplay.so", "_ZN10W6NzgawMJy10iPzUgaQKcQEdddRK10C8THgaTQxFP10MpGzgariDy"), new NativeCallback((a, b, c, d, e, f) => {
        if (unhit) return;
        hurtPlayer(a, b, c, d, e, f);
    }, "void", ["pointer", "double", "double", "double", "pointer", "pointer"]));

    function makeExplosion(level) {
        if (!level) return;
        const playerX = getlocalx(activeplayer);
        const playerY = getlocaly(activeplayer);
        const radius = explosionSize;
        const offset = radius / 2;
        for (let i = 0; i < radius; i++) {
            for (let j = 0; j < radius; j++) {
                putExplosion(level, playerX + offset - i, playerY + offset - j, 1, 0, 1);
            }
        }
    }

    Interceptor.attach(Module.findExportByName("libqplay.so", "_ZN10zF9VgaBKxR10iUxUgaX7aQEdd"), {
        onEnter: function(args) {
            if (!canExplode) return;
            canExplode = false;
            makeExplosion(args[0]);
        }
    });

    const call_showAdmins = { on: () => { showAdmins = true }, off: () => { showAdmins = false } };
    const call_autoFarm = { on: () => { if (!explosionsInterval) explosionsInterval = setInterval(() => { canExplode = true }, 1000) }, off: () => { if (explosionsInterval) { clearInterval(explosionsInterval); explosionsInterval = null; canExplode = false; } } };
    let afkInterval = null;
    const call_antiAfk = { on: () => { if (!afkInterval) afkInterval = setInterval(click, 240 * 1000) }, off: () => { if (afkInterval) { clearInterval(afkInterval); afkInterval = null; } } };
    const call_unhit = { on: () => { unhit = true }, off: () => { unhit = false } };
    const call_autoOFF = { on: () => { autoOFF = true }, off: () => { autoOFF = false } };
    const call_wallhack = { on: () => { wallhack = true }, off: () => { wallhack = false } };

    Java.perform(function() {
        Java.scheduleOnMainThread(function() {
            const classLoader = getClassLoader();
            const mainActivity = getMainActivity(classLoader);
            if (!mainActivity) {
                showToast("Não foi possível obter a Activity principal.");
                return;
            }
            menu = new Menu(classLoader, mainActivity);
            
            menu.createMenuStart("MENU", 15, "#006400");
            menu.createMenuLayout("#18122B", 420, 280); // Largura, Altura
            menu.createMenuBarLayout("#635985");
            menu.createMenuBarTitle("EngModMobile", "#FFC107");
            menu.createMenuOptionsLayout("#443C68", "#393053");

            menu.addOption("autoFarm", "Auto Farm", call_autoFarm);
            // NOVO: Seletor de raio da explosão
            menu.addSeekBar("Raio da Explosão:", explosionSize, 1, 100, (value, type) => {
                explosionSize = value;
                if (type === 'end') {
                    showToast(`Raio da explosão: ${value}x${value}`, 0);
                }
            });
            
            menu.addOption("unhit", "Unhit (God Mode)", call_unhit);
            menu.addOption("wallhack", "Wallhack", call_wallhack);
            menu.addText("--- Utilitários ---", 12, "#FFFFFF");
            // NOVO: Opção "Show Admins" começa ativada
            menu.addOption("showAdmins", "Show Admins", call_showAdmins, true);
            menu.addOption("autoOFF", "Auto Off", call_autoOFF);
            menu.addOption("antiAfk", "Anti AFK", call_antiAfk);
            
            menu.start();

            // NOVO: Loop para atualizar as informações do jogador
            setInterval(() => {
                const props = getPlayerProperties(activeplayer);
                if (menu) {
                    menu.updatePlayerInfo(props);
                }
            }, 1000); // Atualiza a cada segundo
        });
    });

    function getFunc(lib, func, type, params) {
        return new NativeFunction(Module.findExportByName(lib, func), type, params);
    }

    function createTString(str) {
        var str_pointer = malloc(4), str_struct = malloc(str.length + 8);
        str_pointer.writePointer(str_struct);
        str_struct.writeInt(str.length);
        ptr(parseInt(str_struct) + 4).writeInt(1);
        ptr(parseInt(str_struct) + 8).writeUtf8String(str);
        return str_pointer;
    }

    function readTString(str) {
        if (str && !str.isNull()) {
            var pstr = str.readPointer();
            if (pstr && !pstr.isNull()) {
                var strlen = pstr.readInt();
                if (strlen > 0) return ptr(parseInt(pstr) + 8).readCString(strlen);
            }
        }
        return null;
    }

    function click() {
        Java.perform(() => Java.scheduleOnMainThread(() => {
            const classLoader = getClassLoader();
            const mainActivity = getMainActivity(classLoader);
            if (!mainActivity) return;
            
            let time = Java.use("android.os.SystemClock").uptimeMillis();
            let event = Java.use("android.view.MotionEvent").obtain(time, time + 50, 0, 500, 500, 0);
            mainActivity.dispatchTouchEvent(event);
        }));
    }

}, 5000);
