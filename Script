setTimeout(() => {
    var malloc = getFunc("libc.so", "malloc", "pointer", ["int"]);

    // Variável para controlar o raio da explosão, com valor padrão
    let explosionRadius = 80;

    // ========================================================================
    // Funções Utilitárias
    // ========================================================================

    function getClassLoader() {
        return {
            Gravity: Java.use("android.view.Gravity"),
            TextView: Java.use("android.widget.TextView"),
            LinearLayout: Java.use("android.widget.LinearLayout"),
            LinearLayout_LayoutParams: Java.use("android.widget.LinearLayout$LayoutParams"),
            Color: Java.use("android.graphics.Color"),
            ActivityThread: Java.use("android.app.ActivityThread"),
            View_OnTouchListener: Java.use("android.view.View$OnTouchListener"),
            MotionEvent: Java.use("android.view.MotionEvent"),
            String: Java.use("java.lang.String"),
            View: Java.use("android.view.View"),
        };
    }

    function pixelDensityToPixels(context, dp) {
        const density = context.getResources().getDisplayMetrics().density.value;
        return parseInt(dp * density);
    }

    function getMainActivity(classLoader) {
        const activityThread = classLoader.ActivityThread.sCurrentActivityThread.value;
        const mActivities = activityThread.mActivities.value;
        const activityClientRecord = Java.cast(mActivities.valueAt(0), Java.use("android.app.ActivityThread$ActivityClientRecord"));
        return activityClientRecord.activity.value;
    }

    function showToast(text, time = 0) {
        Java.perform(() => {
            Java.scheduleOnMainThread(function() {
                var toast = Java.use("android.widget.Toast");
                var context = Java.use("android.app.ActivityThread").currentApplication().getApplicationContext();
                toast.makeText(context, Java.use("java.lang.String").$new(text), time).show();
            });
        });
    }

    // ========================================================================
    // Funções e Ponteiros do Jogo (Inalterado)
    // ========================================================================
    const activeplayer = Module.findExportByName("libqplay.so", "dkCHgaGRiF").readPointer();
    const getlocaly = new NativeFunction(Module.findExportByName("libqplay.so", "_ZNK10W6NzgawMJy10qCgWga1ADREv"), "double", ["pointer"]);
    const getlocalx = new NativeFunction(Module.findExportByName("libqplay.so", "_ZNK10W6NzgawMJy10Qi2VgaCyrREv"), "double", ["pointer"]);
    const putExplosion = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10zF9VgaBKxR10tMaombuGXrEdddii"), "void", ["pointer", "double", "double", "double", "int", "int"]);
    let hurtPlayer = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10W6NzgawMJy10iPzUgaQKcQEdddRK10C8THgaTQxFP10MpGzgariDy"), "void", ["pointer", "double", "double", "double", "pointer", "pointer"]);
    const setVarValue = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10G0gxgajWBw10gVHMMaRyAEERK10C8THgaTQxF"), "void", ["pointer", "pointer"]);
    const alpha = createTString('alpha=0.5');
    const zoom = createTString('zoom=1');

    // Variáveis de Estado (Inalterado)
    let canExplode = false, explosionsInterval = null, unhit = false, wallhack = false;
    let showAdmins = true, autoOFF = false, afkInterval = null;
    let autoOffHasTriggered = false;
    let autoOffButtons = [];

    // Lógica e Hooks (Inalterado)
    function getPlayerProperties(p) { /*...*/ return { "alpha": Memory.readFloat(p.add(356)), "zoom": Memory.readFloat(p.add(0x138)), "x": Memory.readDouble(p.add(0x238)), "y": Memory.readDouble(p.add(0x240)), "nick": readTString(p.add(464)), "account": readTString(p.add(696)), }; }
    Interceptor.attach(Module.findExportByName("libqplay.so", "_ZN10zF9VgaBKxR10CGk7IaA0MzEddb"), { 'onLeave': function(ret) { if (wallhack) ret.replace(0); } });
    Interceptor.attach(Module.findExportByName("libqplay.so", "_ZN10MpGzgariDy10Q3v7IaUAWzERK10C8THgaTQxF"), { 'onEnter': function(args) { if (autoOFF && args[0].toInt32() != activeplayer.toInt32() && !autoOffHasTriggered) { autoOffHasTriggered = true; showToast("Outro player detectado. Desativando cheats."); Java.scheduleOnMainThread(() => { for (const button of autoOffButtons) { button.reset(); } }); } if (!showAdmins) return; const accRgx = /^(pc\:|graal\d+|guest.*)/; const props = getPlayerProperties(args[0]); if (props.alpha < 0.5) setVarValue(args[0], alpha); if (props.zoom < 1) setVarValue(args[0], zoom); if (!props.account) return; const account = props.account.toLowerCase(); if (account === '') return; if (!accRgx.test(account)) { showToast('Admin: ' + account); } } });
    Interceptor.replace(Module.findExportByName("libqplay.so", "_ZN10W6NzgawMJy10iPzUgaQKcQEdddRK10C8THgaTQxFP10MpGzgariDy"), new NativeCallback((a, b, c, d, e, f) => { if (unhit) return 0; hurtPlayer(a, b, c, d, e, f); }, "void", ["pointer", "double", "double", "double", "pointer", "pointer"]));
    Interceptor.attach(Module.findExportByName("libqplay.so", "_ZN10zF9VgaBKxR10iUxUgaX7aQEdd"), { onEnter: function(args) { if (!canExplode) return; canExplode = false; makeExplosion(args[0], explosionRadius); } });
    function makeExplosion(level, radius) { if (!level) return; const playerX = getlocalx(activeplayer); const playerY = getlocaly(activeplayer); const offset = Math.floor(radius / 2); for (let i = 0; i < radius; i++) { for (let j = 0; j < radius; j++) { putExplosion(level, playerX + offset - i, playerY + offset - j, 1, 0, 1); } } }
    const call_showAdmins = { on() { showAdmins = true; }, off() { showAdmins = false; } };
    const call_explode = { on() { if (!explosionsInterval) explosionsInterval = setInterval(() => { canExplode = true; }, 1000); }, off() { if (explosionsInterval) { clearInterval(explosionsInterval); explosionsInterval = null; canExplode = false; } } };
    const call_antiAfk = { on() { if (!afkInterval) afkInterval = setInterval(click, 240 * 1000); }, off() { if (afkInterval) { clearInterval(afkInterval); afkInterval = null; } } };
    const call_unhit = { on() { unhit = true; }, off() { unhit = false; } };
    const call_autoOFF = { on() { autoOFF = true; autoOffHasTriggered = false; }, off() { autoOFF = false; } };
    const call_wallhack = { on() { wallhack = true; }, off() { wallhack = false; } };

    // ========================================================================
    // Criação da Interface Gráfica (UI)
    // ========================================================================
    Java.perform(function () {
        Java.scheduleOnMainThread(function () {
            const classLoader = getClassLoader();
            const mainActivity = getMainActivity(classLoader);
            const Gravity = classLoader.Gravity;
            const View = classLoader.View;

            const COLOR_OFF = classLoader.Color.parseColor("#80000000");
            const COLOR_ON = classLoader.Color.parseColor("#80008000");
            const PADDING = pixelDensityToPixels(mainActivity, 8);
            const MARGIN = pixelDensityToPixels(mainActivity, 2);

            function createToggleButton(text, callbacks, startOn = false) {
                const button = classLoader.TextView.$new(mainActivity);
                let isOn = startOn;
                
                // CORRIGIDO: A função reset agora FORÇA o estado 'desligado'.
                // Ela não verifica mais o estado 'isOn', garantindo que sempre funcione.
                const reset = () => {
                    isOn = false; // Força o estado lógico interno
                    button.setBackgroundColor(COLOR_OFF); // Força o estado visual
                    callbacks.off(); // Força a execução da lógica de desativação
                };
                
                button.setText(classLoader.String.$new(text));
                button.setTextColor(classLoader.Color.WHITE.value);
                button.setBackgroundColor(isOn ? COLOR_ON : COLOR_OFF);
                button.setPadding(PADDING, PADDING, PADDING, PADDING);
                
                const layoutParams = classLoader.LinearLayout_LayoutParams.$new(-2, -2);
                layoutParams.setMargins(MARGIN, MARGIN, MARGIN, MARGIN);
                button.setLayoutParams(layoutParams);

                button.setOnClickListener(Java.registerClass({
                    name: "com.example.ClickListener" + Math.random().toString(36).substring(2),
                    implements: [Java.use("android.view.View$OnClickListener")],
                    methods: {
                        onClick(v) {
                            isOn = !isOn;
                            v.setBackgroundColor(isOn ? COLOR_ON : COLOR_OFF);
                            if (isOn) callbacks.on(); else callbacks.off();
                        }
                    }
                }).$new());
                
                return { view: button, reset: reset };
            }

            function createHoldButton(text, action) { /*...*/ const button = classLoader.TextView.$new(mainActivity); let holdInterval = null; button.setText(classLoader.String.$new(text)); button.setTextColor(classLoader.Color.WHITE.value); button.setBackgroundColor(COLOR_OFF); button.setPadding(PADDING, PADDING, PADDING, PADDING); const layoutParams = classLoader.LinearLayout_LayoutParams.$new(-2, -2); layoutParams.setMargins(MARGIN, MARGIN, MARGIN, MARGIN); button.setLayoutParams(layoutParams); button.setOnTouchListener(Java.registerClass({ name: "com.example.TouchListener" + Math.random().toString(36).substring(2), implements: [classLoader.View_OnTouchListener], methods: { onTouch(v, event) { switch (event.getAction()) { case classLoader.MotionEvent.ACTION_DOWN.value: action(); holdInterval = setInterval(action, 100); return true; case classLoader.MotionEvent.ACTION_UP.value: if (holdInterval) clearInterval(holdInterval); holdInterval = null; return true; } return false; } } }).$new()); return button; }

            // --- Montagem da UI ---

            // Layout da Barra Inferior (será escondido/mostrado)
            const mainBarLayout = classLoader.LinearLayout.$new(mainActivity);
            mainBarLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            mainBarLayout.setGravity(Gravity.CENTER.value);
            
            const bottomLayout = classLoader.LinearLayout.$new(mainActivity);
            const bottomParams = classLoader.LinearLayout_LayoutParams.$new(-1, -1);
            bottomLayout.setLayoutParams(bottomParams);
            bottomLayout.setGravity(Gravity.CENTER_HORIZONTAL.value | Gravity.BOTTOM.value);
            bottomLayout.addView(mainBarLayout);

            // Layout da Barra Superior
            const topInfoTextView = classLoader.TextView.$new(mainActivity);
            topInfoTextView.setTextColor(classLoader.Color.WHITE.value);
            topInfoTextView.setShadowLayer(5, 0, 0, classLoader.Color.BLACK.value);
            
            const topBarLayout = classLoader.LinearLayout.$new(mainActivity); // NOVO: Container para o botão e o texto
            topBarLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            topBarLayout.setGravity(Gravity.CENTER_VERTICAL.value);

            const topLayout = classLoader.LinearLayout.$new(mainActivity);
            const topParams = classLoader.LinearLayout_LayoutParams.$new(-1, -1);
            topLayout.setLayoutParams(topParams);
            topLayout.setGravity(Gravity.TOP.value | Gravity.CENTER_HORIZONTAL.value);
            topLayout.addView(topBarLayout); // Adiciona o container em vez do texto diretamente

            // NOVO: Botão para Ocultar/Mostrar a barra de cheats
            const call_hideCheats = {
                on() { 
                    bottomLayout.setVisibility(View.VISIBLE.value); 
                },
                off() { 
                    bottomLayout.setVisibility(View.GONE.value); 
                }
            };
            const hideCheatsButton = createToggleButton("[v]", call_hideCheats, true);
            // Lógica customizada para trocar o texto do botão
            hideCheatsButton.view.setOnClickListener(Java.registerClass({
                name: "com.example.HideClickListener" + Math.random().toString(36).substring(2),
                implements: [Java.use("android.view.View$OnClickListener")],
                methods: {
                    onClick(v) {
                        const isVisible = bottomLayout.getVisibility() == View.VISIBLE.value;
                        if (isVisible) {
                            call_hideCheats.off();
                            v.setText(classLoader.String.$new("[^]"));
                        } else {
                            call_hideCheats.on();
                            v.setText(classLoader.String.$new("[v]"));
                        }
                    }
                }
            }).$new());

            topBarLayout.addView(hideCheatsButton.view);
            topBarLayout.addView(topInfoTextView);

            // Funções para adicionar botões
            const addAutoOffButton = (text, callbacks, startOn = false) => {
                const button = createToggleButton(text, callbacks, startOn);
                mainBarLayout.addView(button.view);
                autoOffButtons.push(button);
            };
            const addRegularButton = (text, callbacks, startOn = false) => {
                 const button = createToggleButton(text, callbacks, startOn);
                 mainBarLayout.addView(button.view);
            };
            
            // Adiciona botões à barra inferior
            addAutoOffButton("Auto Off", call_autoOFF);
            addAutoOffButton("Wall Hack", call_wallhack);
            addAutoOffButton("Anti Afk", call_antiAfk);
            addRegularButton("Revelar ADM", call_showAdmins, true);

            const explosionControlLayout = classLoader.LinearLayout.$new(mainActivity);
            explosionControlLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            explosionControlLayout.setGravity(Gravity.CENTER.value);
            const explosionButton = createToggleButton(`Explodir: ${explosionRadius}`, call_explode);
            autoOffButtons.push(explosionButton);
            const updateRadiusText = () => Java.scheduleOnMainThread(() => explosionButton.view.setText(classLoader.String.$new(`Explodir: ${explosionRadius}`)));
            const decreaseAction = () => { explosionRadius = Math.max(1, explosionRadius - 1); updateRadiusText(); };
            const increaseAction = () => { explosionRadius = Math.min(100, explosionRadius + 1); updateRadiusText(); };
            explosionControlLayout.addView(createHoldButton("<", decreaseAction));
            explosionControlLayout.addView(explosionButton.view);
            explosionControlLayout.addView(createHoldButton(">", increaseAction));
            mainBarLayout.addView(explosionControlLayout);
            addAutoOffButton("Unhit", call_unhit);

            // Adiciona os layouts principais na tela
            mainActivity.addContentView(topLayout, topParams);
            mainActivity.addContentView(bottomLayout, bottomParams);

            // Lógica de atualização do texto de info (Inalterado)
            setInterval(() => {
                const props = getPlayerProperties(activeplayer);
                Java.scheduleOnMainThread(function() {
                    const infoText = `  Nome: ${props.nick} | ID: ${props.account} | Pos: (${props.x.toFixed(2)}, ${props.y.toFixed(2)})`;
                    topInfoTextView.setText(classLoader.String.$new(infoText));
                });
            }, 500);
        });
    });

    // Funções de Baixo Nível (Inalterado)
    function getFunc(lib, func, type, params) { return new NativeFunction(Module.findExportByName(lib, func), type, params); }
    function createTString(str) { var str_pointer = malloc(4); var str_struct = malloc(str.length + 8); str_pointer.writePointer(str_struct); str_struct.writeInt(str.length); ptr(parseInt(str_struct) + 4).writeInt(1); ptr(parseInt(str_struct) + 8).writeUtf8String(str); return str_pointer; }
    function readTString(str) { if (!str.isNull() && parseInt(str) != 0) { var pstr = str.readPointer(); if (!pstr.isNull()) { var strlen = pstr.readInt(); if (strlen > 0) return ptr(parseInt(pstr) + 8).readCString(strlen); } } return ""; }
    function click() { Java.perform(() => Java.scheduleOnMainThread(() => { let time = Java.use("android.os.SystemClock").uptimeMillis(); let event = Java.use("android.view.MotionEvent").obtain(time, time + 50, 0, 1, 1, 0); getMainActivity(getClassLoader()).dispatchTouchEvent(event); })); }
}, 15000);

