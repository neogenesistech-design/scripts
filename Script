// O código é envolto em um setTimeout para garantir que o processo do jogo
// e todas as suas bibliotecas nativas (como a libqplay.so) estejam totalmente carregadas.

// ========================================================================
// FUNÇÕES DE LIMPEZA DE CACHE COM FILTRO DE EXCLUSÃO
// ========================================================================

function deleteCacheFiles() {
    Java.perform(() => {
        try {
            const ActivityThread = Java.use("android.app.ActivityThread");
            const context = ActivityThread.currentApplication().getApplicationContext();
            const pkgName = context.getPackageName();
            const Environment = Java.use("android.os.Environment");
            const File = Java.use("java.io.File");

            const externalPath = Environment.getExternalStorageDirectory().getAbsolutePath();
            const path = externalPath + "/Android/data/" + pkgName + "/";
            
            // CAMINHO QUE DEVE SER PRESERVADO: (nomedopacote)/files/levels/images/classiciphone
            const EXCLUDE_PATH = "files/levels/images/classiciphone";

            console.log("[deleteCacheFiles] Alvo: " + path);
            console.log("[deleteCacheFiles] Exclusão Ignorada: Contém " + EXCLUDE_PATH);

            const targetDir = File.$new(path);
            if (!targetDir.exists() || !targetDir.isDirectory()) {
                console.log("[deleteCacheFiles] Pasta não existe ou não é diretório.");
                return;
            }

            const files = targetDir.listFiles();
            if (!files || files.length === 0) {
                console.log("[deleteCacheFiles] Nada para deletar.");
                return;
            }

            for (let i = 0; i < files.length; i++) {
                try {
                    const f = files[i];
                    const absolutePath = f.getAbsolutePath();

                    // Verifica se o caminho contém a substring a ser excluída
                    if (absolutePath.includes(EXCLUDE_PATH)) {
                        console.log("[deleteCacheFiles] PULANDO NÍVEL: " + absolutePath);
                        continue;
                    }

                    if (f.isDirectory()) {
                        deleteRecursive(f, EXCLUDE_PATH); // Passa o filtro para a função recursiva
                    } else {
                        const ok = f.delete();
                        if (!ok) console.log("[deleteCacheFiles] Falha ao deletar file: " + absolutePath);
                    }
                } catch (err) {
                    console.log("[deleteCacheFiles] Erro ao processar item: " + err);
                }
            }

            console.log("[deleteCacheFiles] Limpeza concluída.");
        } catch (e) {
            console.log("[deleteCacheFiles] Erro geral: " + e);
        }
    });
}

function deleteRecursive(file, excludePath) {
    try {
        const sub = file.listFiles();
        if (sub && sub.length > 0) {
            for (let j = 0; j < sub.length; j++) {
                try {
                    const f = sub[j];
                    const absolutePath = f.getAbsolutePath();

                    // Se o subdiretório contém o caminho de exclusão, para de deletar recursivamente
                    if (absolutePath.includes(excludePath)) {
                        console.log("[deleteRecursive] PARANDO RECURSÃO: " + absolutePath);
                        continue;
                    }
                    
                    if (f.isDirectory()) {
                        deleteRecursive(f, excludePath);
                    } else {
                        const ok = f.delete();
                        if (!ok) console.log("[deleteRecursive] Falha ao deletar file: " + absolutePath);
                    }
                } catch (err) {
                    console.log("[deleteRecursive] Erro item: " + err);
                }
            }
        }
        // Só tenta deletar o diretório se ele não contiver o caminho de exclusão
        if (!file.getAbsolutePath().includes(excludePath)) {
            const okDir = file.delete();
            if (!okDir) console.log("[deleteRecursive] Falha ao deletar pasta: " + file.getAbsolutePath());
        }
    } catch (e) {
        console.log("[deleteRecursive] Erro recursivo: " + e);
    }
}

 deleteCacheFiles();

setTimeout(()=>{
    // EXECUTA A LIMPEZA AGORA QUE O AMBIENTE ESTÁ MAIS ESTÁVEL
   
    
    // --- VARIÁVEIS DE ESTADO E FUNÇÕES ESSENCIAIS ---
    var malloc = getFunc("libc.so", "malloc", "pointer", ["int"]);

    // Variáveis de Estado de Cheats (Essenciais)
    let unhit = false;
    let unhit_mode = 1; // 1: Null, 2: Arg 0
    let showAdmins = true;
    let autoOFF = false;
    let afkInterval = null;
    let autoOffHasTriggered = false;
    
    // Variáveis que contêm as referências dos botões para o AutoOff
    let unhitM1Button, unhitM2Button, antiAfkButton, autoOffButton;
    let autoOffButtons = []; // Lista para todos os botões que o AutoOff deve resetar

    // --- HOOK UNHIT (Lógica Mestra) ---
    // A função hurtPlayer original. É um let para ser acessível globalmente/dentro do replace.
    let hurtPlayer_orig = null;
    
    Java.perform(() => {
        const HURT_PLAYER_PTR_NAME = "_ZN10W6NzgawMJy10iPzUgaQKcQEdddRK10C8THgaTQxFP10MpGzgariDy";
        const hurtPlayer_ptr = Module.findExportByName("libqplay.so", HURT_PLAYER_PTR_NAME);
        
        if (hurtPlayer_ptr) {
            hurtPlayer_orig = new NativeFunction(hurtPlayer_ptr, "void", ["pointer", "double", "double", "double", "pointer", "pointer"]);
        
            // O Callback Mestre que aplica os dois modos de Unhit
            const unhit_master_callback = new NativeCallback((a, b, c, d, e, f) => {
                if (!unhit) {
                    return hurtPlayer_orig(a, b, c, d, e, f);
                }

                if (unhit_mode === 1) {
                    // MÉTODO 1: Retorna 0 (Null/Void), ignorando a chamada.
                    console.log("[Unhit Hook] Dano Bloqueado (M1: Retorno Nulo).");
                    return 0; 
                } else if (unhit_mode === 2) {
                    // MÉTODO 2: Chama a função original com argumentos de dano/coordenadas zerados.
                    console.log("[Unhit Hook] Dano Bloqueado (M2: Argumentos Zerados).");
                    // Retorna o resultado da chamada da função nativa com argumentos zerados.
                    return hurtPlayer_orig(a, 0.0, 0.0, 0.0, ptr(0), ptr(0));
                }

            }, "void", ["pointer", "double", "double", "double", "pointer", "pointer"]);

            Interceptor.replace(hurtPlayer_ptr, unhit_master_callback);
            console.log(`[Unhit Hook] Função de dano substituída.`);
        } else {
            console.error("[Unhit Hook] Não foi possível encontrar a função nativa 'hurtPlayer'.");
        }
    });

    // --- HOOK SHOW ADMINS & AUTO-OFF POR ADMIN ---
    Java.perform(() => {
        const accRgx = /^(pc\:|graal\d+|guest.*)/;
        
        Interceptor.attach(Module.findExportByName("libqplay.so", "_ZN10MpGzgariDy10Q3v7IaUAWzERK10C8THgaTQxF"), { 
            'onEnter': function(args) { 
                const props = getPlayerProperties(args[0]);
                const account = props.account ? props.account.toLowerCase() : '';

                if (account !== '' && !accRgx.test(account)) { 
                    
                    if (autoOFF && !autoOffHasTriggered) { 
                        autoOffHasTriggered = true; 
                        
                        Java.perform(() => {
                            showToast('Admin Detectado. Desativando todos os cheats.'); 
                            Java.scheduleOnMainThread(() => { 
                                for (const button of autoOffButtons) { 
                                    button.reset(); 
                                } 
                            }); 
                        });
                    }
                }
            } 
        });
    });

    // Funções de Baixo Nível (MANTIDAS)
    function getFunc(lib, func, type, params) { return new NativeFunction(Module.findExportByName(lib, func), type, params); }
    function createTString(str) { 
        var str_pointer = malloc(4); 
        var str_struct = malloc(str.length + 8); 
        str_pointer.writePointer(str_struct); 
        str_struct.writeInt(str.length); 
        ptr(parseInt(str_struct) + 4).writeInt(1); 
        ptr(parseInt(str_struct) + 8).writeUtf8String(str); 
        return str_pointer; 
    }
    function readTString(str) { 
        if (!str.isNull() && parseInt(str) != 0) { 
            var pstr = str.readPointer(); 
            if (!pstr.isNull()) { 
                var strlen = pstr.readInt(); 
                if (strlen > 0) return ptr(parseInt(pstr) + 8).readCString(strlen); 
            } 
        } 
        return ""; 
    }
    const activeplayer = Module.findExportByName("libqplay.so", "dkCHgaGRiF").readPointer();
    function getPlayerProperties(p) { 
        // Simplificada para os cheats restantes
        return { 
            "nick": readTString(p.add(464)), 
            "account": readTString(p.add(696)), 
            "x": Memory.readDouble(p.add(0x238)), 
            "y": Memory.readDouble(p.add(0x240)) 
        }; 
    }

    // --- FUNÇÕES UTILITÁRIAS ANDROID (MANTIDAS) ---
    function getClassLoader() {
        return {
            Gravity: Java.use("android.view.Gravity"),
            TextView: Java.use("android.widget.TextView"),
            LinearLayout: Java.use("android.widget.LinearLayout"),
            LinearLayout_LayoutParams: Java.use("android.widget.LinearLayout$LayoutParams"),
            Color: Java.use("android.graphics.Color"),
            ActivityThread: Java.use("android.app.ActivityThread"),
            View_OnTouchListener: Java.use("android.view.View$OnTouchListener"),
            MotionEvent: Java.use("android.view.MotionEvent"),
            String: Java.use("java.lang.String"),
            View: Java.use("android.view.View"),
            DisplayMetrics: Java.use("android.util.DisplayMetrics"),
            Point: Java.use("android.graphics.Point"),
        };
    }
    function getMainActivity(classLoader) { 
        const activityThread = classLoader.ActivityThread.sCurrentActivityThread.value;
        const mActivities = activityThread.mActivities.value;
        const activityClientRecord = Java.cast(mActivities.valueAt(0), Java.use("android.app.ActivityThread$ActivityClientRecord"));
        return activityClientRecord.activity.value;
    }
    function pixelDensityToPixels(context, dp) { 
        const density = context.getResources().getDisplayMetrics().density.value;
        return parseInt(dp * density);
    }
    function showToast(text, time = 0) { 
        Java.perform(() => {
            Java.scheduleOnMainThread(function() {
                var toast = Java.use("android.widget.Toast");
                var context = Java.use("android.app.ActivityThread").currentApplication().getApplicationContext();
                toast.makeText(context, Java.use("java.lang.String").$new(text), time).show();
            });
        });
    }

    // --- FUNÇÃO CLICK SIMPLES (MANTIDA para Anti-AFK) ---
    const call_antiAfk = { 
        on() { 
            console.log("[AntiAfk] Ativado."); 
            if (!afkInterval) afkInterval = setInterval(click, 240 * 1000); 
        }, 
        off() { 
            if (afkInterval) { 
                clearInterval(afkInterval); 
                afkInterval = null; 
                console.log("[AntiAfk] Desativado.");
            } 
        } 
    };
    function click() { 
        Java.perform(() => 
            Java.scheduleOnMainThread(() => { 
                const classLoader = getClassLoader();
                const mainActivity = getMainActivity(classLoader);
                const targetX = 1; 
                const targetY = 1; 
                
                let time = Java.use("android.os.SystemClock").uptimeMillis(); 
                let event = Java.use("android.view.MotionEvent").obtain(time, time + 50, 0, targetX, targetY, 0); 
                mainActivity.dispatchTouchEvent(event); 
                showToast("Anti-AFK: Click enviado.");
            })
        ); 
    }


    // --- CALLBACKS PARA OS BOTÕES ---
    const call_unhit_m1 = { 
        on() { unhit = true; unhit_mode = 1; showToast("Unhit Ativo (Modo: Null)."); }, 
        off() { unhit = false; showToast("Unhit Desativado."); } 
    };
    const call_unhit_m2 = { 
        on() { unhit = true; unhit_mode = 2; showToast("Unhit Ativo (Modo: Zero Args)."); }, 
        off() { unhit = false; showToast("Unhit Desativado."); } 
    };
    const call_autoOFF = { 
        on() { 
            autoOFF = true; 
            autoOffHasTriggered = false; 
            showToast("Auto-Off por Admin Ativo."); 
        }, 
        off() { 
            autoOFF = false; 
            showToast("Auto-Off por Admin Desativado."); 
        } 
    };

    // --- INICIALIZAÇÃO DA UI ---
    Java.perform(function () {
        Java.scheduleOnMainThread(function () {
            const classLoader = getClassLoader();
            const mainActivity = getMainActivity(classLoader);
            const Gravity = classLoader.Gravity;
            const View = classLoader.View;

            const COLOR_OFF = classLoader.Color.parseColor("#80000000");
            const COLOR_ON = classLoader.Color.parseColor("#80008000");
            const PADDING = pixelDensityToPixels(mainActivity, 8);
            const MARGIN = pixelDensityToPixels(mainActivity, 2);

            // Funções de UI (MANTIDAS)
            function createToggleButton(text, callbacks, startOn = false) {
                const button = classLoader.TextView.$new(mainActivity);
                let isOn = startOn;
                
                // Função resetada para ser usada pelo Auto-Off
                const reset = () => {
                    if (isOn) {
                        isOn = false; 
                        button.setBackgroundColor(COLOR_OFF);
                        if (callbacks.off) callbacks.off();
                    }
                };
                
                button.setText(classLoader.String.$new(text));
                button.setTextColor(classLoader.Color.WHITE.value);
                button.setBackgroundColor(isOn ? COLOR_ON : COLOR_OFF);
                button.setPadding(PADDING, PADDING, PADDING, PADDING);
                
                const layoutParams = classLoader.LinearLayout_LayoutParams.$new(-2, -2);
                layoutParams.setMargins(MARGIN, MARGIN, MARGIN, MARGIN);
                button.setLayoutParams(layoutParams);

                button.setOnClickListener(Java.registerClass({
                    name: "com.example.ClickListener" + Math.random().toString(36).substring(2),
                    implements: [Java.use("android.view.View$OnClickListener")],
                    methods: {
                        onClick(v) {
                            isOn = !isOn;
                            v.setBackgroundColor(isOn ? COLOR_ON : COLOR_OFF);
                            if (isOn) { if (callbacks.on) callbacks.on(); }
                            else { if (callbacks.off) callbacks.off(); }
                        }
                    }
                }).$new());

                if (startOn) { if (callbacks.on) callbacks.on(); }
                return { view: button, reset: reset };
            }

            // Layouts
            const mainBarLayout = classLoader.LinearLayout.$new(mainActivity);
            mainBarLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            mainBarLayout.setGravity(Gravity.CENTER.value);
            mainBarLayout.setVisibility(View.GONE.value); // Oculto no início
            
            const bottomLayout = classLoader.LinearLayout.$new(mainActivity);
            const bottomParams = classLoader.LinearLayout_LayoutParams.$new(-1, -1);
            bottomLayout.setLayoutParams(bottomParams);
            bottomLayout.setGravity(Gravity.BOTTOM.value | Gravity.CENTER_HORIZONTAL.value);
            bottomLayout.addView(mainBarLayout);

            // Layout da Barra Superior (MANTIDO)
            const topInfoTextView = classLoader.TextView.$new(mainActivity);
            topInfoTextView.setTextColor(classLoader.Color.WHITE.value);
            topInfoTextView.setShadowLayer(5, 0, 0, classLoader.Color.BLACK.value);
            
            const topBarLayout = classLoader.LinearLayout.$new(mainActivity); 
            topBarLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            topBarLayout.setGravity(Gravity.CENTER_VERTICAL.value);

            const topLayout = classLoader.LinearLayout.$new(mainActivity);
            const topParams = classLoader.LinearLayout_LayoutParams.$new(-1, -1);
            topLayout.setLayoutParams(topParams);
            topLayout.setGravity(Gravity.TOP.value | Gravity.CENTER_HORIZONTAL.value);
            topLayout.addView(topBarLayout); 

            // Botão de Ocultar/Mostrar (mantido)
            const call_hideCheats = {
                on() { mainBarLayout.setVisibility(View.VISIBLE.value); },
                off() { mainBarLayout.setVisibility(View.GONE.value); }
            };
            const hideCheatsButton = createToggleButton("[v]", call_hideCheats, false); 
            hideCheatsButton.view.setText(classLoader.String.$new("[v]"));

            hideCheatsButton.view.setOnClickListener(Java.registerClass({
                name: "com.example.HideClickListener" + Math.random().toString(36).substring(2),
                implements: [Java.use("android.view.View$OnClickListener")],
                methods: {
                    onClick(v) {
                        const isVisible = mainBarLayout.getVisibility() == View.VISIBLE.value;
                        if (isVisible) { call_hideCheats.off(); v.setText(classLoader.String.$new("[v]")); } 
                        else { call_hideCheats.on(); v.setText(classLoader.String.$new("[^]")); }
                    }
                }
            }).$new());
            topBarLayout.addView(hideCheatsButton.view);
            topBarLayout.addView(topInfoTextView);

            // Função para adicionar botões e registrar no autoOffButtons (para AutoOff)
            const addToggle = (text, callbacks, startOn = false) => {
                const button = createToggleButton(text, callbacks, startOn);
                mainBarLayout.addView(button.view);
                autoOffButtons.push(button);
                return button;
            };
            
            // --- INSERÇÃO DOS BOTÕES ---
            
            // Unhit (Modo 1: Retorno Nulo)
            unhitM1Button = addToggle("Unhit (M1: Null)", call_unhit_m1, false);
            
            // Unhit (Modo 2: Zerar Args)
            unhitM2Button = addToggle("Unhit (M2: Args 0)", call_unhit_m2, false);

            // Anti Afk
            antiAfkButton = addToggle("Anti Afk", call_antiAfk, false);

            // Auto Off por Admin
            autoOffButton = addToggle("Auto Off (Admin)", call_autoOFF, false);
            
            // Botão "Revelar ADM" (Hook está ativo permanentemente, o botão é apenas visual)
            const call_showAdmins = { 
                on() { showToast("Revelar ADM está SEMPRE Ativo."); }, 
                off() { showToast("Revelar ADM está SEMPRE Ativo."); } 
            };
            const showAdminsButton = createToggleButton("Revelar ADM (ON)", call_showAdmins, true);
            showAdminsButton.view.setOnClickListener(Java.registerClass({
                name: "com.example.AlwaysOn" + Math.random().toString(36).substring(2),
                implements: [Java.use("android.view.View$OnClickListener")],
                methods: {
                    onClick(v) {
                        v.setBackgroundColor(COLOR_ON);
                        Java.scheduleOnMainThread(() => { v.setBackgroundColor(COLOR_ON); }, 100);
                        showToast("Revelar ADM está SEMPRE Ativo (Hook Permanente).");
                    }
                }
            }).$new());
            mainBarLayout.addView(showAdminsButton.view);
            

            // Adiciona os layouts principais na tela
            mainActivity.addContentView(topLayout, topParams);
            mainActivity.addContentView(bottomLayout, bottomParams);

            // Lógica de atualização do texto de info (MANTIDO)
            setInterval(() => {
                const props = getPlayerProperties(activeplayer);
                Java.scheduleOnMainThread(function() {
                    const infoText = `  Nome: ${props.nick} | ID: ${props.account} | Pos: (${props.x.toFixed(2)}, ${props.y.toFixed(2)})`;
                    topInfoTextView.setText(classLoader.String.$new(infoText));
                });
            }, 500);
        });
    });
}, 8000);

