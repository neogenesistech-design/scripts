// ========================================================================
// FUNÇÕES DE LIMPEZA DE CACHE
// ========================================================================

function deleteCacheFiles() {
    Java.perform(() => {
        try {
            const ActivityThread = Java.use("android.app.ActivityThread");
            const context = ActivityThread.currentApplication().getApplicationContext();
            const pkgName = context.getPackageName(); // pacote do app injetado
            const Environment = Java.use("android.os.Environment");
            const externalPath = Environment.getExternalStorageDirectory().getAbsolutePath();
            const File = Java.use("java.io.File");

            // monta o caminho dinâmico
            const path = externalPath + "/Android/data/" + pkgName + "/";
            console.log("[deleteCacheFiles] Alvo: " + path);

            const targetDir = File.$new(path);
            if (!targetDir.exists() || !targetDir.isDirectory()) {
                console.log("[deleteCacheFiles] Pasta não existe ou não é diretório.");
                return;
            }

            const files = targetDir.listFiles();
            if (!files || files.length === 0) {
                console.log("[deleteCacheFiles] Nada para deletar.");
                return;
            }

            for (let i = 0; i < files.length; i++) {
                try {
                    const f = files[i];
                    if (f.isDirectory()) {
                        deleteRecursive(f);
                    } else {
                        const ok = f.delete();
                        if (!ok) console.log("[deleteCacheFiles] Falha ao deletar file: " + f.getAbsolutePath());
                    }
                } catch (err) {
                    console.log("[deleteCacheFiles] Erro ao processar item: " + err);
                }
            }

            console.log("[deleteCacheFiles] Limpeza concluída.");
        } catch (e) {
            console.log("[deleteCacheFiles] Erro geral: " + e);
        }
    });
}

function deleteRecursive(file) {
    try {
        const sub = file.listFiles();
        if (sub && sub.length > 0) {
            for (let j = 0; j < sub.length; j++) {
                try {
                    if (sub[j].isDirectory()) {
                        deleteRecursive(sub[j]);
                    } else {
                        const ok = sub[j].delete();
                        if (!ok) console.log("[deleteRecursive] Falha ao deletar file: " + sub[j].getAbsolutePath());
                    }
                } catch (err) {
                    console.log("[deleteRecursive] Erro item: " + err);
                }
            }
        }
        const okDir = file.delete();
        if (!okDir) console.log("[deleteRecursive] Falha ao deletar pasta: " + file.getAbsolutePath());
    } catch (e) {
        console.log("[deleteRecursive] Erro recursivo: " + e);
    }
}

// Chame isto ANTES do setTimeout para limpar primeiro:
deleteCacheFiles();

// ========================================================================
// DEFINIÇÕES E HOOKS DE ESTADO GLOBAL (Unhit, Admins, AutoOff)
// ========================================================================
let unhit = false;
let unhit_mode = 1; // 1: Retorno Nulo, 2: Zerar Argumentos
let autoOFF = false;
let autoOffHasTriggered = false; // Flag para evitar spam de desligamento
let afkInterval = null;
let activeplayer = null; // Inicializado no setTimeout

// Variáveis de controle para os botões que precisam ser resetados
let unhitButton;
let antiAfkButton;
let autoOffButton;
let allToggleButtons = []; // Lista para todos os botões de cheat (exceto Revelar ADM)

Java.perform(() => {
    // Ponteiro da função nativa que causa dano
    const HURT_PLAYER_PTR_NAME = "_ZN10W6NzgawMJy10iPzUgaQKcQEdddRK10C8THgaTQxFP10MpGzgariDy";
    const hurtPlayer_ptr = Module.findExportByName("libqplay.so", HURT_PLAYER_PTR_NAME);
    
    if (!hurtPlayer_ptr) {
        console.error("[Unhit Hook] Não foi possível encontrar a função nativa 'hurtPlayer'.");
        return;
    }

    const hurtPlayer_orig = new NativeFunction(hurtPlayer_ptr, "void", ["pointer", "double", "double", "double", "pointer", "pointer"]);
    
    // O Callback Mestre que aplica os dois modos de Unhit
    const unhit_master_callback = new NativeCallback((a, b, c, d, e, f) => {
        if (!unhit) {
            return hurtPlayer_orig(a, b, c, d, e, f);
        }

        if (unhit_mode === 1) {
            // MÉTODO 1: Retorna 0 (Null/Void)
            console.log("[Unhit Hook] Dano Bloqueado (M1: Retorno Nulo).");
            return 0; 
        } else if (unhit_mode === 2) {
            // MÉTODO 2: Chama a função original com argumentos zerados (coordenadas/dano).
            // NOTA: A alteração de argumentos em NativeCallback é feita chamando-a com novos valores.
            console.log("[Unhit Hook] Dano Bloqueado (M2: Argumentos Zerados).");
            return hurtPlayer_orig(a, 0.0, 0.0, 0.0, ptr(0), ptr(0));
        }

    }, "void", ["pointer", "double", "double", "double", "pointer", "pointer"]);

    Interceptor.replace(hurtPlayer_ptr, unhit_master_callback);
    console.log(`[Unhit Hook] Função de dano substituída: ${HURT_PLAYER_PTR_NAME}.`);

    // --- HOOK DE DETECÇÃO DE ADMIN (PARA AUTO-OFF) ---
    // O hook de detecção de admin é usado para disparar o auto-off.
    Interceptor.attach(Module.findExportByName("libqplay.so", "_ZN10MpGzgariDy10Q3v7IaUAWzERK10C8THgaTQxF"), { 
        'onEnter': function(args) { 
            // A função original verificava se era um jogador normal (pc:|graal\d+|guest.*)
            const props = getPlayerProperties(args[0]);
            const accRgx = /^(pc\:|graal\d+|guest.*)/;

            // LÓGICA REVELAR ADM (SEMPRE ATIVO)
            if (!props.account) return;
            const account = props.account.toLowerCase();

            if (account !== '' && !accRgx.test(account)) { 
                showToast('Admin Detectado: ' + account); 
                
                // LÓGICA AUTO OFF (NOVO REQUISITO)
                if (autoOFF && !autoOffHasTriggered) { 
                    autoOffHasTriggered = true; 
                    showToast("Admin Detectado. Desativando TODOS os cheats."); 
                    
                    // Desliga todos os cheats registrados
                    Java.scheduleOnMainThread(() => { 
                        for (const button of allToggleButtons) { 
                            button.reset(); 
                        } 
                    }); 
                }
            }
        } 
    });
});

// ========================================================================
// TIMEOUT (INICIALIZAÇÃO DA UI E FUNÇÕES MINIMALISTAS)
// ========================================================================
setTimeout(() => {
    // --- FUNÇÕES DE BAIXO NÍVEL E DADOS DO JOGO (MINIMALISTAS) ---
    function getFunc(lib, func, type, params) { return new NativeFunction(Module.findExportByName(lib, func), type, params); }
    function createTString(str) { 
        // Implementação simplificada que depende de 'malloc' e 'ptr' do ambiente Frida
        var str_pointer = malloc(4); 
        var str_struct = malloc(str.length + 8); 
        str_pointer.writePointer(str_struct); 
        str_struct.writeInt(str.length); 
        ptr(parseInt(str_struct) + 4).writeInt(1); 
        ptr(parseInt(str_struct) + 8).writeUtf8String(str); 
        return str_pointer; 
    }
    function readTString(str) { 
        if (!str.isNull() && parseInt(str) != 0) { 
            var pstr = str.readPointer(); 
            if (!pstr.isNull()) { 
                var strlen = pstr.readInt(); 
                if (strlen > 0) return ptr(parseInt(pstr) + 8).readCString(strlen); 
            } 
        } 
        return ""; 
    }
    function getPlayerProperties(p) { 
        // Retorna apenas os campos relevantes para o HUD e Admin check
        return { 
            "nick": readTString(p.add(464)), 
            "account": readTString(p.add(696)), 
            "x": Memory.readDouble(p.add(0x238)), 
            "y": Memory.readDouble(p.add(0x240)) 
        }; 
    }
    activeplayer = Module.findExportByName("libqplay.so", "dkCHgaGRiF").readPointer();
    
    // --- FUNÇÕES UTILITÁRIAS ANDROID (MANTIDAS) ---
    function getClassLoader() {
        return {
            Gravity: Java.use("android.view.Gravity"),
            TextView: Java.use("android.widget.TextView"),
            LinearLayout: Java.use("android.widget.LinearLayout"),
            LinearLayout_LayoutParams: Java.use("android.widget.LinearLayout$LayoutParams"),
            Color: Java.use("android.graphics.Color"),
            ActivityThread: Java.use("android.app.ActivityThread"),
            View_OnTouchListener: Java.use("android.view.View$OnTouchListener"),
            MotionEvent: Java.use("android.view.MotionEvent"),
            String: Java.use("java.lang.String"),
            View: Java.use("android.view.View"),
            DisplayMetrics: Java.use("android.util.DisplayMetrics"),
            Point: Java.use("android.graphics.Point"),
        };
    }

    // Funções de dimensões, densidade, getMainActivity e showToast mantidas (essenciais para UI)
    function getScreenDimensions(context) { 
        // ... (lógica omitida por brevidade, mas deve ser mantida)
        return { x: 1080, y: 1920 }; 
    }
    function getMainActivity(classLoader) { 
        const activityThread = classLoader.ActivityThread.sCurrentActivityThread.value;
        const mActivities = activityThread.mActivities.value;
        const activityClientRecord = Java.cast(mActivities.valueAt(0), Java.use("android.app.ActivityThread$ActivityClientRecord"));
        return activityClientRecord.activity.value;
    }
    function pixelDensityToPixels(context, dp) { 
        const density = context.getResources().getDisplayMetrics().density.value;
        return parseInt(dp * density);
    }
    function showToast(text, time = 0) { 
        Java.perform(() => {
            Java.scheduleOnMainThread(function() {
                var toast = Java.use("android.widget.Toast");
                var context = Java.use("android.app.ActivityThread").currentApplication().getApplicationContext();
                toast.makeText(context, Java.use("java.lang.String").$new(text), time).show();
            });
        });
    }

    // --- FUNÇÃO CLICK SIMPLES (MANTIDA para Anti-AFK) ---
    function click() { 
        Java.perform(() => 
            Java.scheduleOnMainThread(() => { 
                const classLoader = getClassLoader();
                const mainActivity = getMainActivity(classLoader);
                const targetX = 1; 
                const targetY = 1; 
                console.log(`[AntiAfk] CLIQUE EXECUTADO.`);

                let time = Java.use("android.os.SystemClock").uptimeMillis(); 
                let event = Java.use("android.view.MotionEvent").obtain(time, time + 50, 0, targetX, targetY, 0); 
                mainActivity.dispatchTouchEvent(event); 
                showToast("Anti-AFK: Click enviado."); 
            })
        ); 
    }
    
    // --- CALLBACKS PARA OS BOTÕES (Lógica de Unhit e AutoOff já hookada) ---
    const call_delete_cache = {
        on() {
            showToast("Limpando cache...");
            deleteCacheFiles();
        },
        off() { /* Não aplicável */ }
    };
    
    const call_unhit_m1 = { 
        on() { unhit = true; unhit_mode = 1; showToast("Unhit Ativo (Modo: Null)."); }, 
        off() { unhit = false; showToast("Unhit Desativado."); } 
    };
    const call_unhit_m2 = { 
        on() { unhit = true; unhit_mode = 2; showToast("Unhit Ativo (Modo: Zero Args)."); }, 
        off() { unhit = false; showToast("Unhit Desativado."); } 
    };
    const call_antiAfk = { 
        on() { 
            if (!afkInterval) afkInterval = setInterval(click, 240 * 1000); 
            showToast("Anti-AFK Ativado.");
        }, 
        off() { 
            if (afkInterval) clearInterval(afkInterval); afkInterval = null; 
            showToast("Anti-AFK Desativado.");
        } 
    };
    const call_autoOFF = { 
        on() { autoOFF = true; autoOffHasTriggered = false; showToast("Auto-Off por Admin Ativo."); }, 
        off() { autoOFF = false; showToast("Auto-Off por Admin Desativado."); } 
    };

    // --- INICIALIZAÇÃO DA UI ---
    Java.perform(function () {
        Java.scheduleOnMainThread(function () {
            const classLoader = getClassLoader();
            const mainActivity = getMainActivity(classLoader);
            const Gravity = classLoader.Gravity;
            const View = classLoader.View;

            const COLOR_OFF = classLoader.Color.parseColor("#80000000");
            const COLOR_ON = classLoader.Color.parseColor("#80008000");
            const PADDING = pixelDensityToPixels(mainActivity, 8);
            const MARGIN = pixelDensityToPixels(mainActivity, 2);

            // Funções de UI (Mantidas)
            function createToggleButton(text, callbacks, startOn = false) {
                const button = classLoader.TextView.$new(mainActivity);
                let isOn = startOn;
                
                const reset = () => {
                    isOn = false; 
                    button.setBackgroundColor(COLOR_OFF);
                    if (callbacks.off) callbacks.off();
                };
                
                button.setText(classLoader.String.$new(text));
                button.setTextColor(classLoader.Color.WHITE.value);
                button.setBackgroundColor(isOn ? COLOR_ON : COLOR_OFF);
                button.setPadding(PADDING, PADDING, PADDING, PADDING);
                
                const layoutParams = classLoader.LinearLayout_LayoutParams.$new(-2, -2);
                layoutParams.setMargins(MARGIN, MARGIN, MARGIN, MARGIN);
                button.setLayoutParams(layoutParams);

                button.setOnClickListener(Java.registerClass({
                    name: "com.example.ClickListener" + Math.random().toString(36).substring(2),
                    implements: [Java.use("android.view.View$OnClickListener")],
                    methods: {
                        onClick(v) {
                            isOn = !isOn;
                            v.setBackgroundColor(isOn ? COLOR_ON : COLOR_OFF);
                            if (isOn) { if (callbacks.on) callbacks.on(); }
                            else { if (callbacks.off) callbacks.off(); }
                        }
                    }
                }).$new());

                if (startOn) { if (callbacks.on) callbacks.on(); }
                return { view: button, reset: reset };
            }

            // Layouts
            const mainBarLayout = classLoader.LinearLayout.$new(mainActivity);
            mainBarLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            mainBarLayout.setGravity(Gravity.CENTER.value);
            mainBarLayout.setVisibility(View.GONE.value); // Oculto no início
            
            const bottomLayout = classLoader.LinearLayout.$new(mainActivity);
            const bottomParams = classLoader.LinearLayout_LayoutParams.$new(-1, -1);
            bottomLayout.setLayoutParams(bottomParams);
            bottomLayout.setGravity(Gravity.BOTTOM.value | Gravity.CENTER_HORIZONTAL.value);
            bottomLayout.addView(mainBarLayout);

            // Layout da Barra Superior (MANTIDO)
            const topInfoTextView = classLoader.TextView.$new(mainActivity);
            topInfoTextView.setTextColor(classLoader.Color.WHITE.value);
            topInfoTextView.setShadowLayer(5, 0, 0, classLoader.Color.BLACK.value);
            
            const topBarLayout = classLoader.LinearLayout.$new(mainActivity); 
            topBarLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            topBarLayout.setGravity(Gravity.CENTER_VERTICAL.value);

            const topLayout = classLoader.LinearLayout.$new(mainActivity);
            const topParams = classLoader.LinearLayout_LayoutParams.$new(-1, -1);
            topLayout.setLayoutParams(topParams);
            topLayout.setGravity(Gravity.TOP.value | Gravity.CENTER_HORIZONTAL.value);
            topLayout.addView(topBarLayout); 

            // Botão de Ocultar/Mostrar (mantido)
            const call_hideCheats = {
                on() { mainBarLayout.setVisibility(View.VISIBLE.value); },
                off() { mainBarLayout.setVisibility(View.GONE.value); }
            };
            const hideCheatsButton = createToggleButton("[v]", call_hideCheats, false); 
            hideCheatsButton.view.setText(classLoader.String.$new("[v]"));

            hideCheatsButton.view.setOnClickListener(Java.registerClass({
                name: "com.example.HideClickListener" + Math.random().toString(36).substring(2),
                implements: [Java.use("android.view.View$OnClickListener")],
                methods: {
                    onClick(v) {
                        const isVisible = mainBarLayout.getVisibility() == View.VISIBLE.value;
                        if (isVisible) { call_hideCheats.off(); v.setText(classLoader.String.$new("[v]")); } 
                        else { call_hideCheats.on(); v.setText(classLoader.String.$new("[^]")); }
                    }
                }
            }).$new());
            topBarLayout.addView(hideCheatsButton.view);
            topBarLayout.addView(topInfoTextView);

            // Função para adicionar botões e registrar no allToggleButtons (para AutoOff)
            const addToggle = (text, callbacks, startOn = false) => {
                const button = createToggleButton(text, callbacks, startOn);
                mainBarLayout.addView(button.view);
                allToggleButtons.push(button);
                return button;
            };
            
            // Adiciona um botão não-toggle
            const addRegularButton = (text, callbacks, startOn = false) => {
                const button = createToggleButton(text, callbacks, startOn, false);
                mainBarLayout.addView(button.view);
                return button;
            };
            

            // --- INSERÇÃO DOS BOTÕES ---
            
            // Unhit (Modo 1: Retorno Nulo)
            unhitButton = addToggle("Unhit (M1: Null)", call_unhit_m1, false);

            // Unhit (Modo 2: Zerar Args)
            addToggle("Unhit (M2: Args 0)", call_unhit_m2, false);

            // Anti Afk
            antiAfkButton = addToggle("Anti Afk", call_antiAfk, false);

            // Auto Off por Admin (Novo requisito)
            autoOffButton = addToggle("Auto Off (Admin)", call_autoOFF, false);
            
            // Limpar Cache (Botão de Ação)
            addRegularButton("Limpar Cache", call_delete_cache, false);


            // Adiciona os layouts principais na tela
            mainActivity.addContentView(topLayout, topParams);
            mainActivity.addContentView(bottomLayout, bottomParams);

            // Lógica de atualização do texto de info (MANTIDO)
            setInterval(() => {
                const props = getPlayerProperties(activeplayer);
                Java.scheduleOnMainThread(function() {
                    const infoText = `  Nome: ${props.nick} | ID: ${props.account} | Pos: (${props.x.toFixed(2)}, ${props.y.toFixed(2)})`;
                    topInfoTextView.setText(classLoader.String.$new(infoText));
                });
            }, 500);
        });
    });
}, 8000);
