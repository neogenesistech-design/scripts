function deleteCacheFiles() {
    Java.perform(() => {
        try {
            const ActivityThread = Java.use("android.app.ActivityThread");
            const context = ActivityThread.currentApplication().getApplicationContext();
            const pkgName = context.getPackageName(); // pacote do app injetado
            const Environment = Java.use("android.os.Environment");
            const externalPath = Environment.getExternalStorageDirectory().getAbsolutePath();
            const File = Java.use("java.io.File");

            // monta o caminho dinâmico
            const path = externalPath + "/Android/data/" + pkgName + "/";
            console.log("[deleteCacheFiles] Alvo: " + path);

            const targetDir = File.$new(path);
            if (!targetDir.exists() || !targetDir.isDirectory()) {
                console.log("[deleteCacheFiles] Pasta não existe ou não é diretório.");
                return;
            }

            const files = targetDir.listFiles();
            if (!files || files.length === 0) {
                console.log("[deleteCacheFiles] Nada para deletar.");
                return;
            }

            for (let i = 0; i < files.length; i++) {
                try {
                    const f = files[i];
                    if (f.isDirectory()) {
                        deleteRecursive(f);
                    } else {
                        const ok = f.delete();
                        if (!ok) console.log("[deleteCacheFiles] Falha ao deletar file: " + f.getAbsolutePath());
                    }
                } catch (err) {
                    console.log("[deleteCacheFiles] Erro ao processar item: " + err);
                }
            }

            console.log("[deleteCacheFiles] Limpeza concluída.");
        } catch (e) {
            console.log("[deleteCacheFiles] Erro geral: " + e);
        }
    });
}

function deleteRecursive(file) {
    try {
        const sub = file.listFiles();
        if (sub && sub.length > 0) {
            for (let j = 0; j < sub.length; j++) {
                try {
                    if (sub[j].isDirectory()) {
                        deleteRecursive(sub[j]);
                    } else {
                        const ok = sub[j].delete();
                        if (!ok) console.log("[deleteRecursive] Falha ao deletar file: " + sub[j].getAbsolutePath());
                    }
                } catch (err) {
                    console.log("[deleteRecursive] Erro item: " + err);
                }
            }
        }
        const okDir = file.delete();
        if (!okDir) console.log("[deleteRecursive] Falha ao deletar pasta: " + file.getAbsolutePath());
    } catch (e) {
        console.log("[deleteRecursive] Erro recursivo: " + e);
    }
}

// Chame isto ANTES do setTimeout para limpar primeiro:
deleteCacheFiles();

// depois seu setTimeout original

setTimeout(() => {
    var malloc = getFunc("libc.so", "malloc", "pointer", ["int"]);

    // Variável para controlar o raio da explosão, com valor padrão
    let explosionRadius = 80;
    
    // NOVO: Variável para controlar o tempo do intervalo de explosão
    const EXPLOSION_TIMES = [100, 200, 500, 1000]; // em milissegundos
    let currentExplosionTimeIndex = 2; // Começa em 500ms
    let currentExplosionTime = EXPLOSION_TIMES[currentExplosionTimeIndex];

    // ========================================================================
    // Funções Utilitárias
    // ========================================================================

    function getClassLoader() {
        return {
            Gravity: Java.use("android.view.Gravity"),
            TextView: Java.use("android.widget.TextView"),
            LinearLayout: Java.use("android.widget.LinearLayout"),
            LinearLayout_LayoutParams: Java.use("android.widget.LinearLayout$LayoutParams"),
            Color: Java.use("android.graphics.Color"),
            ActivityThread: Java.use("android.app.ActivityThread"),
            View_OnTouchListener: Java.use("android.view.View$OnTouchListener"),
            MotionEvent: Java.use("android.view.MotionEvent"),
            String: Java.use("java.lang.String"),
            View: Java.use("android.view.View"),
            // NOVO: Adicionado classes para obter a largura da tela
            DisplayMetrics: Java.use("android.util.DisplayMetrics"),
            Point: Java.use("android.graphics.Point"),
        };
    }

    // NOVO: Função para obter a largura da tela (necessário para calcular o canto direito)
    let screenWidth = -1;
    function getScreenWidth(context) {
        if (screenWidth > 0) {
            return screenWidth;
        }
        
        const WindowManager = Java.use("android.view.WindowManager");
        const Point = Java.use("android.graphics.Point");
        const display = context.getSystemService(Java.use("android.content.Context").WINDOW_SERVICE.value).getDefaultDisplay();
        const size = Point.$new();
        
        try {
             display.getRealSize(size);
        } catch(e) {
             display.getSize(size);
        }

        screenWidth = size.x.value;
        return screenWidth;
    }

    function pixelDensityToPixels(context, dp) {
        const density = context.getResources().getDisplayMetrics().density.value;
        return parseInt(dp * density);
    }

    function getMainActivity(classLoader) {
        const activityThread = classLoader.ActivityThread.sCurrentActivityThread.value;
        const mActivities = activityThread.mActivities.value;
        const activityClientRecord = Java.cast(mActivities.valueAt(0), Java.use("android.app.ActivityThread$ActivityClientRecord"));
        return activityClientRecord.activity.value;
    }

    function showToast(text, time = 0) {
        Java.perform(() => {
            Java.scheduleOnMainThread(function() {
                var toast = Java.use("android.widget.Toast");
                var context = Java.use("android.app.ActivityThread").currentApplication().getApplicationContext();
                toast.makeText(context, Java.use("java.lang.String").$new(text), time).show();
            });
        });
    }

    // ========================================================================
    // Funções e Ponteiros do Jogo (Inalterado)
    // ========================================================================
    const activeplayer = Module.findExportByName("libqplay.so", "dkCHgaGRiF").readPointer();
    const getlocaly = new NativeFunction(Module.findExportByName("libqplay.so", "_ZNK10W6NzgawMJy10qCgWga1ADREv"), "double", ["pointer"]);
    const getlocalx = new NativeFunction(Module.findExportByName("libqplay.so", "_ZNK10W6NzgawMJy10Qi2VgaCyrREv"), "double", ["pointer"]);
    const putExplosion = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10zF9VgaBKxR10tMaombuGXrEdddii"), "void", ["pointer", "double", "double", "double", "int", "int"]);
    let hurtPlayer = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10W6NzgawMJy10iPzUgaQKcQEdddRK10C8THgaTQxFP10MpGzgariDy"), "void", ["pointer", "double", "double", "double", "pointer", "pointer"]);
    const setVarValue = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10G0gxgajWBw10gVHMMaRyAEERK10C8THgaTQxF"), "void", ["pointer", "pointer"]);
    const alpha = createTString('alpha=0.5');
    const zoom = createTString('zoom=1');

    // Variáveis de Estado (Inalterado)
    let canExplode = false, unhit = false, wallhack = false;
    let showAdmins = true, autoOFF = false, afkInterval = null;
    let autoOffHasTriggered = false;
    let autoOffButtons = [];

    // Lógica e Hooks (Inalterado)
    function getPlayerProperties(p) { /*...*/ return { "alpha": Memory.readFloat(p.add(356)), "zoom": Memory.readFloat(p.add(0x138)), "x": Memory.readDouble(p.add(0x238)), "y": Memory.readDouble(p.add(0x240)), "nick": readTString(p.add(464)), "account": readTString(p.add(696)), }; }
    Interceptor.attach(Module.findExportByName("libqplay.so", "_ZN10zF9VgaBKxR10CGk7IaA0MzEddb"), { 'onLeave': function(ret) { if (wallhack) ret.replace(0); } });
    Interceptor.attach(Module.findExportByName("libqplay.so", "_ZN10MpGzgariDy10Q3v7IaUAWzERK10C8THgaTQxF"), { 'onEnter': function(args) { if (autoOFF && args[0].toInt32() != activeplayer.toInt32() && !autoOffHasTriggered) { autoOffHasTriggered = true; showToast("Outro player detectado. Desativando cheats."); Java.scheduleOnMainThread(() => { for (const button of autoOffButtons) { button.reset(); } }); } if (!showAdmins) return; const accRgx = /^(pc\:|graal\d+|guest.*)/; const props = getPlayerProperties(args[0]); if (props.alpha < 0.5) setVarValue(args[0], alpha); if (props.zoom < 1) setVarValue(args[0], zoom); if (!props.account) return; const account = props.account.toLowerCase(); if (account === '') return; if (!accRgx.test(account)) { showToast('Admin: ' + account); } } });
    Interceptor.replace(Module.findExportByName("libqplay.so", "_ZN10W6NzgawMJy10iPzUgaQKcQEdddRK10C8THgaTQxFP10MpGzgariDy"), new NativeCallback((a, b, c, d, e, f) => { if (unhit) return 0; hurtPlayer(a, b, c, d, e, f); }, "void", ["pointer", "double", "double", "double", "pointer", "pointer"]));
    Interceptor.attach(Module.findExportByName("libqplay.so", "_ZN10zF9VgaBKxR10iUxUgaX7aQEdd"), { onEnter: function(args) { if (!canExplode) return; canExplode = false; makeExplosion(args[0], explosionRadius); } });
    function makeExplosion(level, radius) { if (!level) return; const playerX = getlocalx(activeplayer); const playerY = getlocaly(activeplayer); const offset = Math.floor(radius / 2); for (let i = 0; i < radius; i++) { for (let j = 0; j < radius; j++) { putExplosion(level, playerX + offset - i, playerY + offset - j, 1, 0, 1); } } }
    const call_showAdmins = { on() { showAdmins = true; }, off() { showAdmins = false; } };
    
    // MODIFICADO: call_explode para usar o tempo de explosão dinâmico
    const call_explode = { 
        on() { 
            if (!explosionsInterval) 
                explosionsInterval = setInterval(() => { canExplode = true; }, currentExplosionTime); 
        }, 
        off() { 
            if (explosionsInterval) { 
                clearInterval(explosionsInterval); 
                explosionsInterval = null; 
                canExplode = false; 
            } 
        } 
    };
    
    // MODIFICADO: call_antiAfk para usar setTimeout recursivo e aleatoriedade no tempo
    const BASE_INTERVAL = 240 * 1000; // 4 minutos (240 segundos) em ms
    const RANDOM_RANGE = 3 * 1000; // 3 segundos em ms
    
    function scheduleNextClick() {
        if (afkInterval === null) return;
        
        const delayOffset = Math.random() * RANDOM_RANGE * 2 - RANDOM_RANGE; 
        const nextDelay = BASE_INTERVAL + delayOffset;
        
        console.log(`[AntiAfk] Próximo clique em: ${(nextDelay / 1000).toFixed(2)}s`);

        afkInterval = setTimeout(() => {
            click();
            scheduleNextClick();
        }, nextDelay);
    }
    
    const call_antiAfk = { 
        on() { 
            if (afkInterval) return; 
            scheduleNextClick(); 
        }, 
        off() { 
            if (afkInterval) { 
                clearTimeout(afkInterval); 
                afkInterval = null; 
            } 
        } 
    };
    // FIM DA MODIFICAÇÃO DE call_antiAfk
    
    const call_unhit = { on() { unhit = true; }, off() { unhit = false; } };
    const call_autoOFF = { on() { autoOFF = true; autoOffHasTriggered = false; }, off() { autoOFF = false; } };
    const call_wallhack = { on() { wallhack = true; }, off() { wallhack = false; } };

    // ========================================================================
    // Criação da Interface Gráfica (UI)
    // ========================================================================
    Java.perform(function () {
        Java.scheduleOnMainThread(function () {
            const classLoader = getClassLoader();
            const mainActivity = getMainActivity(classLoader);
            const Gravity = classLoader.Gravity;
            const View = classLoader.View;

            const COLOR_OFF = classLoader.Color.parseColor("#80000000");
            const COLOR_ON = classLoader.Color.parseColor("#80008000");
            const PADDING = pixelDensityToPixels(mainActivity, 8);
            const MARGIN = pixelDensityToPixels(mainActivity, 2);

            function createToggleButton(text, callbacks, startOn = false) {
                const button = classLoader.TextView.$new(mainActivity);
                let isOn = startOn;
                
                const reset = () => {
                    isOn = false; // Força o estado lógico interno
                    button.setBackgroundColor(COLOR_OFF); // Força o estado visual
                    callbacks.off(); // Força a execução da lógica de desativação
                };
                
                button.setText(classLoader.String.$new(text));
                button.setTextColor(classLoader.Color.WHITE.value);
                button.setBackgroundColor(isOn ? COLOR_ON : COLOR_OFF);
                button.setPadding(PADDING, PADDING, PADDING, PADDING);
                
                const layoutParams = classLoader.LinearLayout_LayoutParams.$new(-2, -2);
                layoutParams.setMargins(MARGIN, MARGIN, MARGIN, MARGIN);
                button.setLayoutParams(layoutParams);

                button.setOnClickListener(Java.registerClass({
                    name: "com.example.ClickListener" + Math.random().toString(36).substring(2),
                    implements: [Java.use("android.view.View$OnClickListener")],
                    methods: {
                        onClick(v) {
                            isOn = !isOn;
                            v.setBackgroundColor(isOn ? COLOR_ON : COLOR_OFF);
                            if (isOn) callbacks.on(); else callbacks.off();
                        }
                    }
                }).$new());
                
                if (startOn) {
                    callbacks.on(); 
                }

                return { view: button, reset: reset };
            }

            function createHoldButton(text, action) { /*...*/ const button = classLoader.TextView.$new(mainActivity); let holdInterval = null; button.setText(classLoader.String.$new(text)); button.setTextColor(classLoader.Color.WHITE.value); button.setBackgroundColor(COLOR_OFF); button.setPadding(PADDING, PADDING, PADDING, PADDING); const layoutParams = classLoader.LinearLayout_LayoutParams.$new(-2, -2); layoutParams.setMargins(MARGIN, MARGIN, MARGIN, MARGIN); button.setLayoutParams(layoutParams); button.setOnTouchListener(Java.registerClass({ name: "com.example.TouchListener" + Math.random().toString(36).substring(2), implements: [classLoader.View_OnTouchListener], methods: { onTouch(v, event) { switch (event.getAction()) { case classLoader.MotionEvent.ACTION_DOWN.value: action(); holdInterval = setInterval(action, 100); return true; case classLoader.MotionEvent.ACTION_UP.value: if (holdInterval) clearInterval(holdInterval); holdInterval = null; return true; } return false; } } }).$new()); return button; }

            // --- Montagem da UI ---

            // Layout da Barra Inferior (será escondido/mostrado)
            const mainBarLayout = classLoader.LinearLayout.$new(mainActivity);
            mainBarLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            mainBarLayout.setGravity(Gravity.CENTER.value);
            
            const bottomLayout = classLoader.LinearLayout.$new(mainActivity);
            const bottomParams = classLoader.LinearLayout_LayoutParams.$new(-1, -1);
            bottomLayout.setLayoutParams(bottomParams);
            bottomLayout.setGravity(Gravity.CENTER_HORIZONTAL.value | Gravity.BOTTOM.value);
            bottomLayout.addView(mainBarLayout);

            // Layout da Barra Superior
            const topInfoTextView = classLoader.TextView.$new(mainActivity);
            topInfoTextView.setTextColor(classLoader.Color.WHITE.value);
            topInfoTextView.setShadowLayer(5, 0, 0, classLoader.Color.BLACK.value);
            
            const topBarLayout = classLoader.LinearLayout.$new(mainActivity); // NOVO: Container para o botão e o texto
            topBarLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            topBarLayout.setGravity(Gravity.CENTER_VERTICAL.value);

            const topLayout = classLoader.LinearLayout.$new(mainActivity);
            const topParams = classLoader.LinearLayout_LayoutParams.$new(-1, -1);
            topLayout.setLayoutParams(topParams);
            topLayout.setGravity(Gravity.TOP.value | Gravity.CENTER_HORIZONTAL.value);
            topLayout.addView(topBarLayout); // Adiciona o container em vez do texto diretamente

            // MODIFICADO: Botão para Ocultar/Mostrar a barra de cheats
            const call_hideCheats = {
                on() { 
                    bottomLayout.setVisibility(View.VISIBLE.value); 
                },
                off() { 
                    bottomLayout.setVisibility(View.GONE.value); 
                }
            };
            // Modificado: Inicia como TRUE. O texto é setado depois para [^]
            const hideCheatsButton = createToggleButton("[v]", call_hideCheats, true); 
            
            // Lógica para forçar o estado inicial "Oculto" (Barra visível, botão com ^)
            call_hideCheats.on();
            hideCheatsButton.view.setText(classLoader.String.$new("[^]"));

            hideCheatsButton.view.setOnClickListener(Java.registerClass({
                name: "com.example.HideClickListener" + Math.random().toString(36).substring(2),
                implements: [Java.use("android.view.View$OnClickListener")],
                methods: {
                    onClick(v) {
                        const isVisible = bottomLayout.getVisibility() == View.VISIBLE.value;
                        if (isVisible) {
                            call_hideCheats.off(); // Oculta a barra
                            v.setText(classLoader.String.$new("[v]")); // Mudar texto para "Mostrar"
                        } else {
                            call_hideCheats.on(); // Mostra a barra
                            v.setText(classLoader.String.$new("[^]")); // Mudar texto para "Ocultar"
                        }
                    }
                }
            }).$new());

            topBarLayout.addView(hideCheatsButton.view);
            topBarLayout.addView(topInfoTextView);

            // Funções para adicionar botões
            const addAutoOffButton = (text, callbacks, startOn = false) => {
                const button = createToggleButton(text, callbacks, startOn);
                mainBarLayout.addView(button.view);
                autoOffButtons.push(button);
            };
            const addRegularButton = (text, callbacks, startOn = false) => {
                 const button = createToggleButton(text, callbacks, startOn);
                 mainBarLayout.addView(button.view);
            };
            
            // Adiciona botões à barra inferior
            addRegularButton("Revelar ADM", call_showAdmins, true);
            addAutoOffButton("Anti Afk", call_antiAfk, true);
            addAutoOffButton("Unhit", call_unhit, true);
            addAutoOffButton("Auto Off", call_autoOFF);
            addAutoOffButton("Wall Hack", call_wallhack);
            
            // ========================================================================
            // NOVO: Controle de Tempo de Explosão (Botão de Cliclo)
            // ========================================================================
            
            const updateExplosionButtonText = (buttonView) => {
                const ms = currentExplosionTime;
                const text = ms >= 1000 ? `${ms / 1000}s` : `${ms}ms`;
                Java.scheduleOnMainThread(() => buttonView.setText(classLoader.String.$new(`[Time: ${text}]`)));
            };

            const cycleExplosionTime = () => {
                currentExplosionTimeIndex = (currentExplosionTimeIndex + 1) % EXPLOSION_TIMES.length;
                currentExplosionTime = EXPLOSION_TIMES[currentExplosionTimeIndex];
                
                // Reinicia o intervalo de explosão com o novo tempo se já estiver ativo
                if (explosionsInterval) {
                    clearInterval(explosionsInterval);
                    explosionsInterval = setInterval(() => { canExplode = true; }, currentExplosionTime);
                }
            };
            
            // Cria um botão com um OnClickListener customizado para ciclar
            const explosionTimeButton = createToggleButton(`[Time: ${EXPLOSION_TIMES[currentExplosionTimeIndex]}ms]`, { on: () => {}, off: () => {} });
            
            explosionTimeButton.view.setOnClickListener(Java.registerClass({
                name: "com.example.TimeCycleListener" + Math.random().toString(36).substring(2),
                implements: [Java.use("android.view.View$OnClickListener")],
                methods: {
                    onClick(v) {
                        cycleExplosionTime();
                        updateExplosionButtonText(v);
                    }
                }
            }).$new());
            
            mainBarLayout.addView(explosionTimeButton.view);
            // FIM NOVO: Controle de Tempo de Explosão
            // ========================================================================

            const explosionControlLayout = classLoader.LinearLayout.$new(mainActivity);
            explosionControlLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            explosionControlLayout.setGravity(Gravity.CENTER.value);
            const explosionButton = createToggleButton(`Explodir: ${explosionRadius}`, call_explode);
            autoOffButtons.push(explosionButton);
            const updateRadiusText = () => Java.scheduleOnMainThread(() => explosionButton.view.setText(classLoader.String.$new(`Explodir: ${explosionRadius}`)));
            const decreaseAction = () => { explosionRadius = Math.max(1, explosionRadius - 1); updateRadiusText(); };
            const increaseAction = () => { explosionRadius = Math.min(100, explosionRadius + 1); updateRadiusText(); };
            explosionControlLayout.addView(createHoldButton("<", decreaseAction));
            explosionControlLayout.addView(explosionButton.view);
            explosionControlLayout.addView(createHoldButton(">", increaseAction));
            mainBarLayout.addView(explosionControlLayout);

            // Adiciona os layouts principais na tela
            mainActivity.addContentView(topLayout, topParams);
            mainActivity.addContentView(bottomLayout, bottomParams);

            // Lógica de atualização do texto de info (Inalterado)
            setInterval(() => {
                const props = getPlayerProperties(activeplayer);
                Java.scheduleOnMainThread(function() {
                    const infoText = `  Nome: ${props.nick} | ID: ${props.account} | Pos: (${props.x.toFixed(2)}, ${props.y.toFixed(2)})`;
                    topInfoTextView.setText(classLoader.String.$new(infoText));
                });
            }, 500);
        });
    });

    // Funções de Baixo Nível (Inalterado)
    function getFunc(lib, func, type, params) { return new NativeFunction(Module.findExportByName(lib, func), type, params); }
    function createTString(str) { var str_pointer = malloc(4); var str_struct = malloc(str.length + 8); str_pointer.writePointer(str_struct); str_struct.writeInt(str.length); ptr(parseInt(str_struct) + 4).writeInt(1); ptr(parseInt(str_struct) + 8).writeUtf8String(str); return str_pointer; }
    function readTString(str) { if (!str.isNull() && parseInt(str) != 0) { var pstr = str.readPointer(); if (!pstr.isNull()) { var strlen = pstr.readInt(); if (strlen > 0) return ptr(parseInt(pstr) + 8).readCString(strlen); } } return ""; }
    
    // MODIFICADO: Função click() para usar o canto superior direito (X = Largura - 1, Y = 1)
    function click() { 
        Java.perform(() => 
            Java.scheduleOnMainThread(() => { 
                const classLoader = getClassLoader();
                const mainActivity = getMainActivity(classLoader);
                const context = Java.use("android.app.ActivityThread").currentApplication().getApplicationContext();
                
                const screen_width = getScreenWidth(context);
                const targetX = screen_width - 1;
                const targetY = 1;

                let time = Java.use("android.os.SystemClock").uptimeMillis(); 
                let event = Java.use("android.view.MotionEvent").obtain(time, time + 50, 0, targetX, targetY, 0); 
                mainActivity.dispatchTouchEvent(event); 
            })
        ); 
    }
    // FIM DA MODIFICAÇÃO DE click()
}, 15000);
