// ========================================================================
// FUNÇÕES DE LIMPEZA DE CACHE (MOVEMOS A EXECUÇÃO PARA O setTimeout)
// ========================================================================

function deleteCacheFiles() {
    Java.perform(() => {
        try {
            const ActivityThread = Java.use("android.app.ActivityThread");
            const context = ActivityThread.currentApplication().getApplicationContext();
            const pkgName = context.getPackageName(); // pacote do app injetado
            const Environment = Java.use("android.os.Environment");
            const externalPath = Environment.getExternalStorageDirectory().getAbsolutePath();
            const File = Java.use("java.io.File");

            // monta o caminho dinâmico
            const path = externalPath + "/Android/data/" + pkgName + "/";
            console.log("[deleteCacheFiles] Alvo: " + path);

            const targetDir = File.$new(path);
            if (!targetDir.exists() || !targetDir.isDirectory()) {
                console.log("[deleteCacheFiles] Pasta não existe ou não é diretório.");
                return;
            }

            const files = targetDir.listFiles();
            if (!files || files.length === 0) {
                console.log("[deleteCacheFiles] Nada para deletar.");
                return;
            }

            for (let i = 0; i < files.length; i++) {
                try {
                    const f = files[i];
                    if (f.isDirectory()) {
                        deleteRecursive(f);
                    } else {
                        const ok = f.delete();
                        if (!ok) console.log("[deleteCacheFiles] Falha ao deletar file: " + f.getAbsolutePath());
                    }
                } catch (err) {
                    console.log("[deleteCacheFiles] Erro ao processar item: " + err);
                }
            }

            console.log("[deleteCacheFiles] Limpeza concluída.");
        } catch (e) {
            console.log("[deleteCacheFiles] Erro geral: " + e);
        }
    });
}

function deleteRecursive(file) {
    try {
        const sub = file.listFiles();
        if (sub && sub.length > 0) {
            for (let j = 0; j < sub.length; j++) {
                try {
                    if (sub[j].isDirectory()) {
                        deleteRecursive(sub[j]);
                    } else {
                        const ok = sub[j].delete();
                        if (!ok) console.log("[deleteRecursive] Falha ao deletar file: " + sub[j].getAbsolutePath());
                    }
                } catch (err) {
                    console.log("[deleteRecursive] Erro item: " + err);
                }
            }
        }
        const okDir = file.delete();
        if (!okDir) console.log("[deleteRecursive] Falha ao deletar pasta: " + file.getAbsolutePath());
    } catch (e) {
        console.log("[deleteRecursive] Erro recursivo: " + e);
    }
}


// A EXECUÇÃO FOI REMOVIDA DAQUI E MOVIDA PARA O setTimeout PARA EVITAR CRASH
// deleteCacheFiles(); 

setTimeout(() => {
    // EXECUTA A LIMPEZA AGORA QUE O AMBIENTE ESTÁ MAIS ESTÁVEL
    deleteCacheFiles();
    
    // --- VARIÁVEIS DE ESTADO E FUNÇÕES ESSENCIAIS ---
    var malloc = getFunc("libc.so", "malloc", "pointer", ["int"]);

    // Variáveis de Estado de Cheats (Essenciais)
    let unhit = false;
    let unhit_mode = 1; // 1: Null, 2: Arg 0
    let showAdmins = true;
    let autoOFF = false;
    let afkInterval = null;
    let autoOffHasTriggered = false;
    
    // Variáveis que contêm as referências dos botões para o AutoOff
    let unhitM1Button, unhitM2Button, antiAfkButton, autoOffButton;
    let autoOffButtons = []; // Lista para todos os botões que o AutoOff deve resetar

    // ========================================================================
    // Funções Utilitárias
    // ========================================================================
    // Funções de Baixo Nível (MANTIDAS)
    function getFunc(lib, func, type, params) { return new NativeFunction(Module.findExportByName(lib, func), type, params); }
    function createTString(str) { 
        var str_pointer = malloc(4); 
        var str_struct = malloc(str.length + 8); 
        str_pointer.writePointer(str_struct); 
        str_struct.writeInt(str.length); 
        ptr(parseInt(str_struct) + 4).writeInt(1); 
        ptr(parseInt(str_struct) + 8).writeUtf8String(str); 
        return str_pointer; 
    }
    function readTString(str) { 
        if (!str.isNull() && parseInt(str) != 0) { 
            var pstr = str.readPointer(); 
            if (!pstr.isNull()) { 
                var strlen = pstr.readInt(); 
                if (strlen > 0) return ptr(parseInt(pstr) + 8).readCString(strlen); 
            } 
        } 
        return ""; 
    }
    
    // Funções de UI e Contexto (MANTIDAS)
    function getClassLoader() {
        return {
            Gravity: Java.use("android.view.Gravity"),
            TextView: Java.use("android.widget.TextView"),
            LinearLayout: Java.use("android.widget.LinearLayout"),
            LinearLayout_LayoutParams: Java.use("android.widget.LinearLayout$LayoutParams"),
            Color: Java.use("android.graphics.Color"),
            ActivityThread: Java.use("android.app.ActivityThread"),
            View_OnTouchListener: Java.use("android.view.View$OnTouchListener"),
            MotionEvent: Java.use("android.view.MotionEvent"),
            String: Java.use("java.lang.String"),
            View: Java.use("android.view.View"),
            DisplayMetrics: Java.use("android.util.DisplayMetrics"),
            Point: Java.use("android.graphics.Point"),
        };
    }
    function getMainActivity(classLoader) { 
        const activityThread = classLoader.ActivityThread.sCurrentActivityThread.value;
        const mActivities = activityThread.mActivities.value;
        const activityClientRecord = Java.cast(mActivities.valueAt(0), Java.use("android.app.ActivityThread$ActivityClientRecord"));
        return activityClientRecord.activity.value;
    }
    function pixelDensityToPixels(context, dp) { 
        const density = context.getResources().getDisplayMetrics().density.value;
        return parseInt(dp * density);
    }
    function showToast(text, time = 0) { 
        Java.perform(() => {
            Java.scheduleOnMainThread(function() {
                var toast = Java.use("android.widget.Toast");
                var context = Java.use("android.app.ActivityThread").currentApplication().getApplicationContext();
                toast.makeText(context, Java.use("java.lang.String").$new(text), time).show();
            });
        });
    }

    // Funções de Jogo (MANTIDAS)
    const activeplayer = Module.findExportByName("libqplay.so", "dkCHgaGRiF").readPointer();
    const setVarValue = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10G0gxgajWBw10gVHMMaRyAEERK10C8THgaTQxF"), "void", ["pointer", "pointer"]);
    const alpha = createTString('alpha=0.5');
    const zoom = createTString('zoom=1');
    function getPlayerProperties(p) { 
        return { 
            "alpha": Memory.readFloat(p.add(356)), 
            "zoom": Memory.readFloat(p.add(0x138)), 
            "x": Memory.readDouble(p.add(0x238)), 
            "y": Memory.readDouble(p.add(0x240)), 
            "nick": readTString(p.add(464)), 
            "account": readTString(p.add(696)), 
        }; 
    }
    
    // --- LÓGICA ANTI-AFK ---
    const call_antiAfk = { 
        on() { 
            console.log("[AntiAfk] Ativado."); 
            if (!afkInterval) afkInterval = setInterval(click, 240 * 1000); 
        }, 
        off() { 
            if (afkInterval) { 
                clearInterval(afkInterval); 
                afkInterval = null; 
                console.log("[AntiAfk] Desativado.");
            } 
        } 
    };
    function click() { 
        Java.perform(() => 
            Java.scheduleOnMainThread(() => { 
                const classLoader = getClassLoader();
                const mainActivity = getMainActivity(classLoader);
                const targetX = 1; 
                const targetY = 1; 
                
                let time = Java.use("android.os.SystemClock").uptimeMillis(); 
                let event = Java.use("android.view.MotionEvent").obtain(time, time + 50, 0, targetX, targetY, 0); 
                mainActivity.dispatchTouchEvent(event); 
                showToast("Anti-AFK: Click enviado.");
            })
        ); 
    }

    // --- LÓGICA UNHIT (M1 & M2) ---
    // Os métodos on/off do unhit agora definem a variável global 'unhit' e o 'unhit_mode'
    const call_unhit_m1 = { 
        on() { 
            unhit = true; 
            unhit_mode = 1; 
            showToast("Unhit Ativo (Modo: Null)."); 
        }, 
        off() { 
            unhit = false; 
            showToast("Unhit Desativado."); 
        } 
    };
    const call_unhit_m2 = { 
        on() { 
            unhit = true; 
            unhit_mode = 2; 
            showToast("Unhit Ativo (Modo: Zero Args)."); 
        }, 
        off() { 
            unhit = false; 
            showToast("Unhit Desativado."); 
        } 
    };

    // --- LÓGICA AUTO OFF ---
    const call_autoOFF = { 
        on() { 
            autoOFF = true; 
            autoOffHasTriggered = false; 
            showToast("Auto-Off por Admin Ativo."); 
        }, 
        off() { 
            autoOFF = false; 
            showToast("Auto-Off por Admin Desativado."); 
        } 
    };


    // ========================================================================
    // CRIAÇÃO DA INTERFACE GRÁFICA (UI)
    // ========================================================================
    Java.perform(function () {
        Java.scheduleOnMainThread(function () {
            const classLoader = getClassLoader();
            const mainActivity = getMainActivity(classLoader);
            const Gravity = classLoader.Gravity;
            const View = classLoader.View;

            const COLOR_OFF = classLoader.Color.parseColor("#80000000");
            const COLOR_ON = classLoader.Color.parseColor("#80008000");
            const PADDING = pixelDensityToPixels(mainActivity, 8);
            const MARGIN = pixelDensityToPixels(mainActivity, 2);

            // Funções de UI (MANTIDAS)
            function createToggleButton(text, callbacks, startOn = false) {
                const button = classLoader.TextView.$new(mainActivity);
                let isOn = startOn;
                
                // Função resetada para ser usada pelo Auto-Off
                const reset = () => {
                    if (isOn) {
                        isOn = false; 
                        button.setBackgroundColor(COLOR_OFF);
                        if (callbacks.off) callbacks.off();
                    }
                };
                
                button.setText(classLoader.String.$new(text));
                button.setTextColor(classLoader.Color.WHITE.value);
                button.setBackgroundColor(isOn ? COLOR_ON : COLOR_OFF);
                button.setPadding(PADDING, PADDING, PADDING, PADDING);
                
                const layoutParams = classLoader.LinearLayout_LayoutParams.$new(-2, -2);
                layoutParams.setMargins(MARGIN, MARGIN, MARGIN, MARGIN);
                button.setLayoutParams(layoutParams);

                button.setOnClickListener(Java.registerClass({
                    name: "com.example.ClickListener" + Math.random().toString(36).substring(2),
                    implements: [Java.use("android.view.View$OnClickListener")],
                    methods: {
                        onClick(v) {
                            isOn = !isOn;
                            v.setBackgroundColor(isOn ? COLOR_ON : COLOR_OFF);
                            if (isOn) { if (callbacks.on) callbacks.on(); }
                            else { if (callbacks.off) callbacks.off(); }
                        }
                    }
                }).$new());

                if (startOn) { if (callbacks.on) callbacks.on(); }
                return { view: button, reset: reset };
            }

            // Layouts
            const mainBarLayout = classLoader.LinearLayout.$new(mainActivity);
            mainBarLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            mainBarLayout.setGravity(Gravity.CENTER.value);
            mainBarLayout.setVisibility(View.GONE.value); // Oculto no início
            
            const bottomLayout = classLoader.LinearLayout.$new(mainActivity);
            const bottomParams = classLoader.LinearLayout_LayoutParams.$new(-1, -1);
            bottomLayout.setLayoutParams(bottomParams);
            bottomLayout.setGravity(Gravity.BOTTOM.value | Gravity.CENTER_HORIZONTAL.value);
            bottomLayout.addView(mainBarLayout);

            // Layout da Barra Superior (MANTIDO)
            const topInfoTextView = classLoader.TextView.$new(mainActivity);
            topInfoTextView.setTextColor(classLoader.Color.WHITE.value);
            topInfoTextView.setShadowLayer(5, 0, 0, classLoader.Color.BLACK.value);
            
            const topBarLayout = classLoader.LinearLayout.$new(mainActivity); 
            topBarLayout.setOrientation(classLoader.LinearLayout.HORIZONTAL.value);
            topBarLayout.setGravity(Gravity.CENTER_VERTICAL.value);

            const topLayout = classLoader.LinearLayout.$new(mainActivity);
            const topParams = classLoader.LinearLayout_LayoutParams.$new(-1, -1);
            topLayout.setLayoutParams(topParams);
            topLayout.setGravity(Gravity.TOP.value | Gravity.CENTER_HORIZONTAL.value);
            topLayout.addView(topBarLayout); 

            // Botão de Ocultar/Mostrar (mantido)
            const call_hideCheats = {
                on() { mainBarLayout.setVisibility(View.VISIBLE.value); },
                off() { mainBarLayout.setVisibility(View.GONE.value); }
            };
            const hideCheatsButton = createToggleButton("[v]", call_hideCheats, false); 
            hideCheatsButton.view.setText(classLoader.String.$new("[v]"));

            hideCheatsButton.view.setOnClickListener(Java.registerClass({
                name: "com.example.HideClickListener" + Math.random().toString(36).substring(2),
                implements: [Java.use("android.view.View$OnClickListener")],
                methods: {
                    onClick(v) {
                        const isVisible = mainBarLayout.getVisibility() == View.VISIBLE.value;
                        if (isVisible) { call_hideCheats.off(); v.setText(classLoader.String.$new("[v]")); } 
                        else { call_hideCheats.on(); v.setText(classLoader.String.$new("[^]")); }
                    }
                }
            }).$new());
            topBarLayout.addView(hideCheatsButton.view);
            topBarLayout.addView(topInfoTextView);

            // Função para adicionar botões e registrar no allToggleButtons (para AutoOff)
            const addToggle = (text, callbacks, startOn = false) => {
                const button = createToggleButton(text, callbacks, startOn);
                mainBarLayout.addView(button.view);
                autoOffButtons.push(button);
                return button;
            };
            
            // --- INSERÇÃO DOS BOTÕES ---
            
            // Unhit (Modo 1: Retorno Nulo)
            unhitM1Button = addToggle("Unhit (M1: Null)", call_unhit_m1, false);
            
            // Unhit (Modo 2: Zerar Args)
            unhitM2Button = addToggle("Unhit (M2: Args 0)", call_unhit_m2, false);

            // Anti Afk
            antiAfkButton = addToggle("Anti Afk", call_antiAfk, false);

            // Auto Off por Admin
            autoOffButton = addToggle("Auto Off (Admin)", call_autoOFF, false);
            
            // Botão "Revelar ADM" (A lógica está no hook, o botão é apenas visual)
            // Mantemos como um botão regular sem estado (já está sempre ON)
            const call_showAdmins = { on() { showToast("Revelar ADM está SEMPRE Ativo."); }, off() { showToast("Revelar ADM está SEMPRE Ativo."); } };
            const showAdminsButton = createToggleButton("Revelar ADM (ON)", call_showAdmins, true);
            showAdminsButton.view.setOnClickListener(Java.registerClass({
                name: "com.example.AlwaysOn" + Math.random().toString(36).substring(2),
                implements: [Java.use("android.view.View$OnClickListener")],
                methods: {
                    onClick(v) {
                        v.setBackgroundColor(COLOR_ON);
                        Java.scheduleOnMainThread(() => { v.setBackgroundColor(COLOR_ON); }, 100);
                        showToast("Revelar ADM está SEMPRE Ativo (Hook Permanente).");
                    }
                }
            }).$new());
            mainBarLayout.addView(showAdminsButton.view);
            

            // Adiciona os layouts principais na tela
            mainActivity.addContentView(topLayout, topParams);
            mainActivity.addContentView(bottomLayout, bottomParams);

            // Lógica de atualização do texto de info (MANTIDO)
            setInterval(() => {
                const props = getPlayerProperties(activeplayer);
                Java.scheduleOnMainThread(function() {
                    const infoText = `  Nome: ${props.nick} | ID: ${props.account} | Pos: (${props.x.toFixed(2)}, ${props.y.toFixed(2)})`;
                    topInfoTextView.setText(classLoader.String.$new(infoText));
                });
            }, 500);
        });
    });
}, 8000);
