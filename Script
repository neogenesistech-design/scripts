setTimeout(() => {
    // Função malloc para alocar memória em código nativo (libc)
    var malloc = getFunc("libc.so", "malloc", "pointer", ["int"])

    // Variável para gerenciar toasts e evitar sobreposição
    let currentToast = null;

    // Função que carrega classes Android necessárias para criar interface de usuário e manipular eventos
    function getClassLoader() {
        const classLoader = {
            Gravity: Java.use("android.view.Gravity"),
            TextView: Java.use("android.widget.TextView"),
            LinearLayout: Java.use("android.widget.LinearLayout"),
            ViewGroup_LayoutParams: Java.use("android.view.ViewGroup$LayoutParams"),
            LinearLayout_LayoutParams: Java.use("android.widget.LinearLayout$LayoutParams"),
            Color: Java.use("android.graphics.Color"),
            ActivityThread: Java.use("android.app.ActivityThread"),
            ActivityThread_ActivityClientRecord: Java.use("android.app.ActivityThread$ActivityClientRecord"),
            View_OnTouchListener: Java.use("android.view.View$OnTouchListener"),
            MotionEvent: Java.use("android.view.MotionEvent"),
            String: Java.use("java.lang.String"),
            ScrollView: Java.use("android.widget.ScrollView"),
            View_OnClickListener: Java.use("android.view.View$OnClickListener"),
            SeekBar: Java.use("android.widget.SeekBar")
        }
        return classLoader
    }

    // Função que converte unidade dp (density independent pixels) para pixels reais na tela
    function pixelDensityToPixels(context, dp) {
        const density = context.getResources().getDisplayMetrics().density.value
        return parseInt(dp * density)
    }

    // Função para obter a Activity principal atual do aplicativo
    function getMainActivity(classLoader) {
        const activityThread = classLoader.ActivityThread.sCurrentActivityThread.value
        const mActivities = activityThread.mActivities.value
        const activityClientRecord = Java.cast(mActivities.valueAt(0), classLoader.ActivityThread_ActivityClientRecord)
        return activityClientRecord.activity.value
    }

    // Função para exibir um Toast, cancelando o anterior se existir
    function showToast(text, time = 1) { // 1 = Long, 0 = Short
        Java.perform(() => {
            Java.scheduleOnMainThread(function() {
                if (currentToast) {
                    currentToast.cancel();
                }
                var toast = Java.use("android.widget.Toast");
                var newToast = toast.makeText(Java.use("android.app.ActivityThread").currentApplication().getApplicationContext(),
                    Java.use("java.lang.String").$new(text), time);
                newToast.show();
                currentToast = newToast;
            });
        });
    }

    // Classe Menu para facilitar criar e gerenciar um menu na interface usando widgets Android
    class Menu {
        #classLoader; #activity; #MATCH_PARENT; #WRAP_CONTENT; #contentView; #mainLayout; #menuStart; #menuLayout; #menuBarLayout; #menuBarTitle; #options; #colorOn; #colorOff;
        #panelsContainerLayout; #leftPanelLayout; #rightPanelLayout; #menuScrollView; #menuScrollLayout; #entityScrollView; #entityListLayout;

        constructor(classLoader, activity) {
            this.#classLoader = classLoader
            this.#activity = activity
            this.#MATCH_PARENT = classLoader.LinearLayout_LayoutParams.MATCH_PARENT.value
            this.#WRAP_CONTENT = classLoader.LinearLayout_LayoutParams.WRAP_CONTENT.value
            this.#options = {}
            this.#createContentView()
            this.#createMainLayout()
        }

        #createContentView() {
            this.#contentView = this.#classLoader.LinearLayout.$new(this.#activity)
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#MATCH_PARENT)
            this.#contentView.setLayoutParams(layoutParams)
            this.#contentView.setGravity(this.#classLoader.Gravity.CENTER.value)
            this.#contentView.setBackgroundColor(this.#classLoader.Color.TRANSPARENT.value)
        }

        #createMainLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
            this.#mainLayout = this.#classLoader.LinearLayout.$new(this.#activity)
            this.#mainLayout.setLayoutParams(layoutParams)
        }

        createMenuLayout(color, width, height) {
            const widthPx = pixelDensityToPixels(this.#activity, width);
            const heightPx = pixelDensityToPixels(this.#activity, height);
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(widthPx, heightPx);
            this.#menuLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#menuLayout.setLayoutParams(layoutParams);
            this.#menuLayout.setBackgroundColor(this.#classLoader.Color.parseColor(color));
            this.#menuLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
        }

        createMenuBarLayout(color) {
            const padding = pixelDensityToPixels(this.#activity, 10)
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT)
            this.#menuBarLayout = this.#classLoader.LinearLayout.$new(this.#activity)
            this.#menuBarLayout.setLayoutParams(layoutParams)
            this.#menuBarLayout.setBackgroundColor(this.#classLoader.Color.parseColor(color))
            this.#menuBarLayout.setPadding(padding, padding, 0, padding)
        }

        createMenuBarTitle(title, color) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
            this.#menuBarTitle = this.#classLoader.TextView.$new(this.#activity)
            this.#menuBarTitle.setLayoutParams(layoutParams)
            this.#menuBarTitle.setText(this.#classLoader.String.$new(title))
            this.#menuBarTitle.setTextColor(this.#classLoader.Color.parseColor(color))
        }

        #createPanelsContainerLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#MATCH_PARENT);
            this.#panelsContainerLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#panelsContainerLayout.setLayoutParams(layoutParams);
            this.#panelsContainerLayout.setOrientation(this.#classLoader.LinearLayout.HORIZONTAL.value);
        }

        #createLeftPanelLayout() {
            // O peso 1.0 define a proporção do painel.
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(0, this.#MATCH_PARENT, 1.0);
            this.#leftPanelLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#leftPanelLayout.setLayoutParams(layoutParams);
            this.#leftPanelLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
        }

        #createRightPanelLayout() {
            // O peso 1.5 faz este painel ser 50% mais largo que o da esquerda.
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(0, this.#MATCH_PARENT, 1.5);
            const padding = pixelDensityToPixels(this.#activity, 8);
            this.#rightPanelLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#rightPanelLayout.setLayoutParams(layoutParams);
            this.#rightPanelLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
            this.#rightPanelLayout.setPadding(padding, padding, padding, padding);

            this.#entityScrollView = this.#classLoader.ScrollView.$new(this.#activity);
            this.#entityListLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#entityListLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);

            const infoTitle = this.#classLoader.TextView.$new(this.#activity);
            infoTitle.setText(this.#classLoader.String.$new("--- Entity List Explorer ---"));
            infoTitle.setTextColor(this.#classLoader.Color.parseColor("#FFC107"));
            infoTitle.setGravity(this.#classLoader.Gravity.CENTER.value);

            this.#entityListLayout.addView(infoTitle);
            this.#entityScrollView.addView(this.#entityListLayout);
            this.#rightPanelLayout.addView(this.#entityScrollView);
        }

        #createMenuScrollView() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#MATCH_PARENT);
            this.#menuScrollView = this.#classLoader.ScrollView.$new(this.#activity);
            const padding = pixelDensityToPixels(this.#activity, 8);
            this.#menuScrollView.setLayoutParams(layoutParams);
            this.#menuScrollView.setPadding(padding, padding, padding, padding);
        }

        #createMenuScrollLayout() {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT);
            this.#menuScrollLayout = this.#classLoader.LinearLayout.$new(this.#activity);
            this.#menuScrollLayout.setLayoutParams(layoutParams);
            this.#menuScrollLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
        }

        createMenuOptionsLayout(colorOn, colorOff) {
            this.#createMenuScrollView();
            this.#createMenuScrollLayout();
            this.#colorOn = colorOn;
            this.#colorOff = colorOff;
        }

        createMenuStart(title, size, color) {
            size = pixelDensityToPixels(this.#activity, size)
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT)
            this.#menuStart = this.#classLoader.TextView.$new(this.#activity)
            this.#menuStart.setLayoutParams(layoutParams)
            this.#menuStart.setText(this.#classLoader.String.$new(title))
            this.#menuStart.setTextSize(size)
            this.#menuStart.setTextColor(this.#classLoader.Color.parseColor(color))
            this.#menuStart.setBackgroundColor(this.#classLoader.Color.WHITE.value)
        }

        #drawContentView() { this.#activity.addContentView(this.#contentView, this.#contentView.getLayoutParams()) }
        #drawMainLayout() { this.#contentView.addView(this.#mainLayout) }
        #drawMenuStart() { this.#mainLayout.addView(this.#menuStart) }

        #buildExpandedMenu() {
            this.#menuBarLayout.addView(this.#menuBarTitle);
            this.#menuLayout.addView(this.#menuBarLayout);
            this.#createPanelsContainerLayout();
            this.#menuLayout.addView(this.#panelsContainerLayout);
            this.#createLeftPanelLayout();
            this.#menuScrollView.addView(this.#menuScrollLayout);
            this.#leftPanelLayout.addView(this.#menuScrollView);
            this.#panelsContainerLayout.addView(this.#leftPanelLayout);
            this.#createRightPanelLayout();
            this.#panelsContainerLayout.addView(this.#rightPanelLayout);
        }

        #clearEntityListUI() {
            if (this.#entityListLayout) {
                const title = this.#entityListLayout.getChildAt(0);
                this.#entityListLayout.removeAllViews();
                this.#entityListLayout.addView(title);
            }
        }

        #addEntityToUI(text) {
            if (this.#entityListLayout) {
                const entityTextView = this.#classLoader.TextView.$new(this.#activity);
                if (text.startsWith("--- LISTA")) {
                    entityTextView.setTextColor(this.#classLoader.Color.parseColor("#03A9F4")); // Azul para cabeçalhos
                } else if (text.trim().startsWith("[ATIVO]")) {
                    entityTextView.setTextColor(this.#classLoader.Color.parseColor("#FFEB3B")); // Amarelo para ativos
                } else {
                    entityTextView.setTextColor(this.#classLoader.Color.parseColor("#AED2FF")); // Cor padrão
                }
                entityTextView.setText(this.#classLoader.String.$new(text));
                this.#entityListLayout.addView(entityTextView);
            }
        }

        updateEntityListUI(entityTexts) {
            Java.scheduleOnMainThread(() => {
                this.#clearEntityListUI();
                if (entityTexts.length === 0) {
                    this.#addEntityToUI("Nenhuma lista de entidades ativas encontrada.");
                } else {
                    entityTexts.forEach(text => {
                        this.#addEntityToUI(text);
                    });
                }
            });
        }

        #createOptionClickEvent(id, optionView, callbacks) {
            const classLoader = this.#classLoader,
                colorOn = this.#colorOn,
                colorOff = this.#colorOff,
                self = this;
            const optionOnClickListener = Java.registerClass({
                name: "com.example." + id,
                implements: [classLoader.View_OnClickListener],
                methods: {
                    onClick(p1) {
                        if (!self.#options[id].state) {
                            p1.setBackgroundColor(classLoader.Color.parseColor(colorOn));
                            self.#options[id].state = true;
                            callbacks.on()
                        } else {
                            p1.setBackgroundColor(classLoader.Color.parseColor(colorOff));
                            self.#options[id].state = false;
                            callbacks.off()
                        }
                    }
                }
            })
            optionView.setOnClickListener(optionOnClickListener.$new())
        }

        addOption(id, name, callbacks) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT),
                padding = pixelDensityToPixels(this.#activity, 5),
                option = this.#classLoader.TextView.$new(this.#activity),
                margin = pixelDensityToPixels(this.#activity, 10);
            option.setText(this.#classLoader.String.$new(name));
            option.setBackgroundColor(this.#classLoader.Color.parseColor(this.#colorOff));
            option.setTextColor(this.#classLoader.Color.parseColor("#EFEFEF"));
            layoutParams.setMargins(0, 0, 0, margin);
            option.setLayoutParams(layoutParams);
            option.setPadding(padding, padding, 0, padding);
            this.#menuScrollLayout.addView(option);
            this.#options[id] = {
                callbacks,
                optionView: option,
                state: false
            };
            this.#createOptionClickEvent(id, option, callbacks);
        }

        turnOffAllOptions() {
            for (const id in this.#options) {
                const optionData = this.#options[id];
                if (optionData.state) {
                    optionData.optionView.setBackgroundColor(this.#classLoader.Color.parseColor(this.#colorOff));
                    optionData.state = false;
                    optionData.callbacks.off();
                }
            }
        }

        addText(text, textSize, textColor) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#WRAP_CONTENT, this.#WRAP_CONTENT),
                margin = pixelDensityToPixels(this.#activity, 5),
                textView = this.#classLoader.TextView.$new(this.#activity);
            textView.setText(this.#classLoader.String.$new(text));
            textView.setTextSize(textSize);
            textView.setTextColor(this.#classLoader.Color.parseColor(textColor));
            layoutParams.setMargins(0, 0, 0, margin);
            textView.setLayoutParams(layoutParams);
            this.#menuScrollLayout.addView(textView);
        }

        addSeekBar(textValue, initialValue, minValue, maxValue, callback) {
            const layoutParams = this.#classLoader.LinearLayout_LayoutParams.$new(this.#MATCH_PARENT, this.#WRAP_CONTENT),
                margin = pixelDensityToPixels(this.#activity, 1),
                seekBar = this.#classLoader.SeekBar.$new(this.#activity, null, 0, Java.use("android.R$style").Widget_Holo_SeekBar.value),
                textView = this.#classLoader.TextView.$new(this.#activity);
            seekBar.setMax(maxValue - minValue);
            seekBar.setProgress(initialValue - minValue);
            layoutParams.setMargins(0, 0, 0, margin);
            seekBar.setLayoutParams(layoutParams);
            const text = Java.use("java.lang.String").$new(textValue + " " + initialValue);
            textView.setText(text)
            textView.setTextColor(this.#classLoader.Color.parseColor("#EFEFEF"))
            const SeekBarChangeListener = Java.use("android.widget.SeekBar$OnSeekBarChangeListener");
            const SeekBarChangeListenerImplementation = Java.registerClass({
                name: "com.example.SeekBarChangeListener" + Math.floor(Math.random() * 1000),
                implements: [SeekBarChangeListener],
                methods: {
                    onProgressChanged(seekBar, progress, fromUser) {
                        const value = progress + minValue,
                            text = Java.use("java.lang.String").$new(textValue + " " + value);
                        textView.setText(text);
                        if (fromUser) callback(value, "move");
                    },
                    onStartTrackingTouch(seekBar) {
                        callback(seekBar.getProgress() + minValue, "start");
                    },
                    onStopTrackingTouch(seekBar) {
                        callback(seekBar.getProgress() + minValue, "end");
                    }
                }
            });
            seekBar.setOnSeekBarChangeListener(SeekBarChangeListenerImplementation.$new());
            this.#menuScrollLayout.addView(textView);
            this.#menuScrollLayout.addView(seekBar);
            textView.setLayoutParams(layoutParams);
            textView.setGravity(this.#classLoader.Gravity.CENTER.value);
        }

        #createMainLayoutEvent() {
            const mainLayout = this.#mainLayout,
                menuLayout = this.#menuLayout,
                menuStart = this.#menuStart,
                classLoader = this.#classLoader;
            let initialX = 0,
                initialY = 0,
                isMove = false,
                isMenuLayout = false,
                initialTouchTime = 0;
            const MainLayoutOnTouchListener = Java.registerClass({
                name: "com.example.MainLayoutEvent",
                implements: [classLoader.View_OnTouchListener],
                methods: {
                    onTouch(view, event) {
                        const menuHeight = menuLayout.getHeight();
                        switch (event.getAction()) {
                            case classLoader.MotionEvent.ACTION_DOWN.value:
                                initialX = view.getX() - event.getRawX();
                                initialY = view.getY() - event.getRawY();
                                isMove = false;
                                initialTouchTime = Date.now();
                                break;
                            case classLoader.MotionEvent.ACTION_UP.value:
                                if (!isMove) {
                                    if (!isMenuLayout) {
                                        const currentY = mainLayout.getY(),
                                            targetY = (currentY + menuHeight / 2) - menuStart.getHeight() / 1.5;
                                        mainLayout.removeView(menuStart);
                                        mainLayout.addView(menuLayout);
                                        mainLayout.setY(targetY);
                                        isMenuLayout = true;
                                    } else {
                                        const currentY = mainLayout.getY(),
                                            targetY = (currentY - menuHeight / 2) + menuStart.getHeight() / 1.5;
                                        mainLayout.removeView(menuLayout);
                                        mainLayout.addView(menuStart);
                                        mainLayout.setY(targetY);
                                        isMenuLayout = false;
                                    }
                                }
                                break;
                            case classLoader.MotionEvent.ACTION_MOVE.value:
                                view.setX(event.getRawX() + initialX);
                                view.setY(event.getRawY() + initialY);
                                if (Date.now() - initialTouchTime > 200) isMove = true;
                                break;
                            default:
                                return false;
                        }
                        return true;
                    }
                }
            })
            this.#mainLayout.setOnTouchListener(MainLayoutOnTouchListener.$new())
        }

        start() {
            this.#drawContentView();
            this.#drawMainLayout();
            this.#drawMenuStart();
            this.#buildExpandedMenu();
            this.#createMainLayoutEvent();
        }
    }

    let menu = null;
    const activeplayer = Module.findExportByName("libqplay.so", "dkCHgaGRiF").readPointer();
    const getlocaly = new NativeFunction(Module.findExportByName("libqplay.so", "_ZNK10W6NzgawMJy10qCgWga1ADREv"), "double", ["pointer"]);
    const getlocalx = new NativeFunction(Module.findExportByName("libqplay.so", "_ZNK10W6NzgawMJy10Qi2VgaCyrREv"), "double", ["pointer"]);
    const putExplosion = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10zF9VgaBKxR10tMaombuGXrEdddii"), "void", ["pointer", "double", "double", "double", "int", "int"]);
    let hurtPlayer = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10W6NzgawMJy10iPzUgaQKcQEdddRK10C8THgaTQxFP10MpGzgariDy"), "void", ["pointer", "double", "double", "double", "pointer", "pointer"]);
    const setVarValue = new NativeFunction(Module.findExportByName("libqplay.so", "_ZN10G0gxgajWBw10gVHMMaRyAEERK10C8THgaTQxF"), "void", ["pointer", "pointer"]);

    let canExplode = false,
        explosionsInterval = null,
        unhit = false,
        wallhack = false,
        autoOFF = false,
        showAdmins = false;
    let explosionSize = 80;
    let entityScannerInterval = null;
    let scanRadius = 1024;
    const alpha = createTString('alpha=0.5');
    const zoom = createTString('zoom=1');
    let entityStateTracker = {};

    // ====================================================================================================
    // == INÍCIO DA LÓGICA DO AUTO-EXPLORER DE LISTAS DE ENTIDADES (VERSÃO AVANÇADA) =======================
    // ====================================================================================================

    function autoScanEntities() {
        if (activeplayer.isNull()) return;

        const now = Date.now();
        const playerX = getlocalx(activeplayer);
        const playerY = getlocaly(activeplayer);
        const maxDistance = 100.0;
        const pointerSize = 4; // 4 bytes para arquitetura 32-bit
        const INACTIVITY_TIMEOUT = 5000; // 5 segundos

        let validEntityPointers = new Map();

        // 1. PRIMEIRA PASSAGEM: Encontra todos os ponteiros válidos que apontam para entidades
        for (let offset = -scanRadius; offset <= scanRadius; offset += pointerSize) {
            try {
                const currentAddress = activeplayer.add(offset);
                const potentialEntityPtr = currentAddress.readPointer();

                if (potentialEntityPtr.isNull()) continue;

                const entityX = potentialEntityPtr.add(0x238).readDouble();
                const entityY = potentialEntityPtr.add(0x240).readDouble();

                if ((entityX === 0 && entityY === 0) || isNaN(entityX) || isNaN(entityY)) continue;

                const distance = Math.sqrt(Math.pow(playerX - entityX, 2) + Math.pow(playerY - entityY, 2));
                if (distance > maxDistance) continue;

                // Armazena o ponteiro da entidade e o endereço onde esse ponteiro foi encontrado
                validEntityPointers.set(currentAddress.toInt32(), potentialEntityPtr);

            } catch (e) { /* Ignora erros de leitura */ }
        }

        let finalDisplayList = [];
        let processedPointers = new Set();
        let processedForTimeout = new Set();

        // 2. SEGUNDA PASSAGEM: Agrupa os ponteiros encontrados em listas sequenciais
        const sortedAddresses = Array.from(validEntityPointers.keys()).sort((a, b) => a - b);

        for (const startAddress of sortedAddresses) {
            if (processedPointers.has(startAddress)) continue;

            let currentList = [];
            let currentAddress = startAddress;

            // Constrói a lista enquanto os endereços forem sequenciais
            while (validEntityPointers.has(currentAddress)) {
                const entityPtr = validEntityPointers.get(currentAddress);
                currentList.push(entityPtr);
                processedPointers.add(currentAddress);
                currentAddress += pointerSize;
            }

            if (currentList.length > 0) {
                let listEntitiesForDisplay = [];

                for (const entityPtr of currentList) {
                    const entityAddressStr = entityPtr.toString();
                    processedForTimeout.add(entityAddressStr); // Marca como visto nesta varredura

                    const entityX = entityPtr.add(0x238).readDouble();
                    const entityY = entityPtr.add(0x240).readDouble();

                    let status = '[NOVO]';
                    let hasMoved = false;
                    let lastMoved = entityStateTracker[entityAddressStr]?.lastMoved || now;

                    if (entityStateTracker[entityAddressStr]) {
                        const lastState = entityStateTracker[entityAddressStr];
                        if (Math.abs(lastState.x - entityX) > 0.01 || Math.abs(lastState.y - entityY) > 0.01) {
                            status = '[ATIVO]';
                            hasMoved = true;
                            lastMoved = now; // Atualiza o timestamp do último movimento
                        } else {
                            status = '[PARADO]';
                        }
                    }

                    // TIMEOUT: Se estiver parado por mais de 5 segundos, pula a exibição
                    if (status === '[PARADO]' && (now - lastMoved) > INACTIVITY_TIMEOUT) {
                        continue;
                    }

                    let entityNick = entityStateTracker[entityAddressStr]?.nick || "N/A";
                    if (entityNick === "N/A") {
                        try {
                            const n = readTString(entityPtr.add(464));
                            if (n) entityNick = n;
                        } catch (e) {}
                    }

                    entityStateTracker[entityAddressStr] = {
                        x: entityX,
                        y: entityY,
                        nick: entityNick,
                        lastMoved: lastMoved
                    };

                    listEntitiesForDisplay.push({
                        text: `  ${status} ${entityNick} @ (${entityX.toFixed(1)}, ${entityY.toFixed(1)})`,
                        active: hasMoved,
                        isNew: status === '[NOVO]'
                    });
                }

                // NOVO FILTRO: Apenas mostra a lista se ela tiver 3 ou mais entidades visíveis
                if (listEntitiesForDisplay.length >= 3) {
                    // Ordena as entidades DENTRO da lista
                    listEntitiesForDisplay.sort((a, b) => (b.active || b.isNew) - (a.active || a.isNew));

                    // Adiciona o cabeçalho da lista e suas entidades à lista de exibição final
                    finalDisplayList.push(`--- LISTA @ 0x${startAddress.toString(16).toUpperCase()} (${listEntitiesForDisplay.length}) ---`);
                    listEntitiesForDisplay.forEach(e => finalDisplayList.push(e.text));
                }
            }
        }

        // 3. LIMPEZA FINAL: Remove do tracker as entidades que não foram vistas nesta varredura
        for (const trackedAddress in entityStateTracker) {
            if (!processedForTimeout.has(trackedAddress)) {
                delete entityStateTracker[trackedAddress];
            }
        }

        if (menu) {
            menu.updateEntityListUI(finalDisplayList);
        }
    }

    // ====================================================================================================
    // == FIM DA LÓGICA DO AUTO-EXPLORER ==================================================================
    // ====================================================================================================

    const call_autoFarm = {
        on() {
            if (!explosionsInterval) explosionsInterval = setInterval(() => {
                canExplode = true
            }, 1000)
        },
        off() {
            if (explosionsInterval) {
                clearInterval(explosionsInterval);
                explosionsInterval = null;
                canExplode = false;
            }
        }
    };
    let afkInterval = null;
    const call_antiAfk = {
        on() {
            if (!afkInterval) afkInterval = setInterval(click, 240 * 1000)
        },
        off() {
            if (afkInterval) {
                clearInterval(afkInterval);
                afkInterval = null;
            }
        }
    };
    const call_unhit = {
        on() {
            unhit = true
        },
        off() {
            unhit = false
        }
    };
    const call_autoOFF = {
        on() {
            autoOFF = true
        },
        off() {
            autoOFF = false
        }
    };
    const call_wallhack = {
        on() {
            wallhack = true
        },
        off() {
            wallhack = false
        }
    };
    const call_showAdmins = {
        on() {
            showAdmins = true
        },
        off() {
            showAdmins = false
        }
    };
    const call_entityScanner = {
        on() {
            if (!entityScannerInterval) {
                entityStateTracker = {}; // Reseta o rastreador ao ativar
                autoScanEntities();
                entityScannerInterval = setInterval(autoScanEntities, 1000); // Roda a cada 1 segundo para maior precisão no timeout
            }
        },
        off() {
            if (entityScannerInterval) {
                clearInterval(entityScannerInterval);
                entityScannerInterval = null;
                if (menu) menu.updateEntityListUI([]);
            }
        }
    };

    Java.perform(function() {
        Java.scheduleOnMainThread(function() {
            const classLoader = getClassLoader(),
                mainActivity = getMainActivity(classLoader);
            menu = new Menu(classLoader, mainActivity)
            menu.createMenuStart("MENU", 15, "#006400")
            menu.createMenuLayout("#18122B", 420, 300)
            menu.createMenuBarLayout("#635985")
            menu.createMenuBarTitle("EngModMobile", "#FFC107")
            menu.createMenuOptionsLayout("#443C68", "#393053")
            menu.addOption("autoFarm", "Auto Farm", call_autoFarm)
            menu.addSeekBar("Raio da Explosão:", explosionSize, 10, 150, function(value, type) {
                explosionSize = value;
                if (type === 'end') {
                    showToast(`Raio da explosão definido para ${value}x${value}.`, 0);
                }
            });
            menu.addOption("unhit", "Unhit (God Mode)", call_unhit)
            menu.addOption("wallhack", "Wallhack", call_wallhack)
            menu.addText("--- Utilitários ---", 12, "#FFFFFF")
            menu.addOption("showAdmins", "Show Admins", call_showAdmins)
            menu.addOption("autoOFF", "Auto Off", call_autoOFF)
            menu.addOption("antiAfk", "Anti AFK", call_antiAfk)
            menu.addText("--- Testes ---", 12, "#FFC107")
            menu.addOption("entityScanner", "Auto-Explorer Entidades", call_entityScanner)
            menu.addSeekBar("Raio da Busca (bytes):", scanRadius, 256, 8192, function(value, type) {
                scanRadius = value;
                if (type === 'end') {
                    showToast(`Raio de busca definido para ${value} bytes.`, 0);
                }
            });
            menu.start()
        })
    })

    function getFunc(lib, func, type, params) {
        return new NativeFunction(Module.findExportByName(lib, func), type, params);
    }

    function createTString(str) {
        var str_pointer = malloc(4),
            str_struct = malloc(str.length + 8);
        str_pointer.writePointer(str_struct);
        str_struct.writeInt(str.length);
        ptr(parseInt(str_struct) + 4).writeInt(1);
        ptr(parseInt(str_struct) + 8).writeUtf8String(str);
        return str_pointer;
    }

    function readTString(str) {
        if (str && !str.isNull()) {
            var pstr = str.readPointer();
            if (pstr && !pstr.isNull()) {
                var strlen = pstr.readInt();
                if (strlen > 0) return ptr(parseInt(pstr) + 8).readCString(strlen);
            }
        }
        return null;
    }

    function click() {
        Java.perform(() => Java.scheduleOnMainThread(() => {
            let time = Java.use("android.os.SystemClock").uptimeMillis(),
                event = Java.use("android.view.MotionEvent").obtain(time, time + 50, 0, 500, 500, 0);
            getMainActivity(getClassLoader()).dispatchTouchEvent(event);
            console.log("Anti-AFK click performed.");
        }));
    }

}, 5000)
