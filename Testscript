// A lógica do Menu (getClassLoader, pixelDensityToPixels, getMainActivity, Menu class)
// ... DEVE SER INSERIDA AQUI (Copie do seu código original) ...

// ========================================================================
// SCRIPT DE ANÁLISE v20 - Investigador de Estrutura de Mensagens
// ... (Seu código original das funções getClassLoader, pixelDensityToPixels, etc., e a classe Menu)
// ...

function getClassLoader() {
    return {
        Gravity: Java.use("android.view.Gravity"),
        TextView: Java.use("android.widget.TextView"),
        LinearLayout: Java.use("android.widget.LinearLayout"),
        LinearLayout_LayoutParams: Java.use("android.widget.LinearLayout$LayoutParams"),
        Color: Java.use("android.graphics.Color"),
        ActivityThread: Java.use("android.app.ActivityThread"),
        View_OnClickListener: Java.use("android.view.View$OnClickListener"),
        String: Java.use("java.lang.String"),
        ScrollView: Java.use("android.widget.ScrollView"),
        View: Java.use("android.view.View"),
        Typeface: Java.use("android.graphics.Typeface"),
    };
}

function pixelDensityToPixels(context, dp) {
    const density = context.getResources().getDisplayMetrics().density.value;
    return parseInt(dp * density);
}

function getMainActivity(classLoader) {
    const activityThread = classLoader.ActivityThread.sCurrentActivityThread.value;
    const mActivities = activityThread.mActivities.value;
    const activityClientRecord = Java.cast(mActivities.valueAt(0), Java.use("android.app.ActivityThread$ActivityClientRecord"));
    return activityClientRecord.activity.value;
}

class Menu {
    #classLoader; #activity; #menuLayout; #controlContainer; #logContainer; #logScrollView; #colorOn; #colorOff; #isExpanded = true;

    constructor(classLoader, activity, title, width, bgColor) {
        this.#classLoader = classLoader;
        this.#activity = activity;
        this.#createStaticLayout(title, width, bgColor);
    }

    #createStaticLayout(title, width, bgColor) {
        const MATCH = -1;
        const WRAP = -2;
        const widthDp = pixelDensityToPixels(this.#activity, width);

        const rootView = this.#classLoader.LinearLayout.$new(this.#activity);
        rootView.setLayoutParams(this.#classLoader.LinearLayout_LayoutParams.$new(MATCH, MATCH));
        rootView.setGravity(this.#classLoader.Gravity.LEFT.value);
        this.rootView = rootView;

        this.#menuLayout = this.#classLoader.LinearLayout.$new(this.#activity);
        const menuParams = this.#classLoader.LinearLayout_LayoutParams.$new(widthDp, WRAP);
        this.#menuLayout.setLayoutParams(menuParams);
        this.#menuLayout.setBackgroundColor(this.#classLoader.Color.parseColor(bgColor));
        this.#menuLayout.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);

        const menuBarLayout = this.#classLoader.TextView.$new(this.#activity);
        menuBarLayout.setText(this.#classLoader.String.$new(title));
        menuBarLayout.setTextColor(this.#classLoader.Color.parseColor("#FFC107"));
        menuBarLayout.setBackgroundColor(this.#classLoader.Color.parseColor("#B3635985"));
        menuBarLayout.setGravity(this.#classLoader.Gravity.CENTER.value);
        menuBarLayout.setPadding(10, 10, 10, 10);
        this.#menuLayout.addView(menuBarLayout);

        this.#controlContainer = this.#classLoader.LinearLayout.$new(this.#activity);
        this.#controlContainer.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
        this.#controlContainer.setPadding(8, 8, 8, 8);
        this.#menuLayout.addView(this.#controlContainer);

        this.#logScrollView = this.#classLoader.ScrollView.$new(this.#activity);
        this.#logScrollView.setLayoutParams(this.#classLoader.LinearLayout_LayoutParams.$new(MATCH, pixelDensityToPixels(this.#activity, 300)));
        this.#logContainer = this.#classLoader.LinearLayout.$new(this.#activity);
        this.#logContainer.setOrientation(this.#classLoader.LinearLayout.VERTICAL.value);
        this.#logContainer.setPadding(8, 8, 8, 8);
        this.#logScrollView.addView(this.#logContainer);
        this.#menuLayout.addView(this.#logScrollView);

        const self = this;
        const View = this.#classLoader.View;
        menuBarLayout.setOnClickListener(Java.registerClass({
            name: "com.logger.ToggleClickListener" + Math.random().toString().replace(".", ""),
            implements: [this.#classLoader.View_OnClickListener],
            methods: {
                onClick(v) {
                    self.#isExpanded = !self.#isExpanded;
                    const visibility = self.#isExpanded ? View.VISIBLE.value : View.GONE.value;
                    self.#controlContainer.setVisibility(visibility);
                    self.#logScrollView.setVisibility(visibility);
                }
            }
        }).$new());
        
        this.rootView.addView(this.#menuLayout);
    }

    setOptionColors(colorOn, colorOff) { this.#colorOn = colorOn; this.#colorOff = colorOff; }

    addOption(id, name, callbacks) {
        const option = this.#classLoader.TextView.$new(this.#activity);
        option.setText(this.#classLoader.String.$new(name));
        option.setBackgroundColor(this.#classLoader.Color.parseColor(this.#colorOff));
        option.setTextColor(this.#classLoader.Color.WHITE.value);
        option.setGravity(this.#classLoader.Gravity.CENTER.value);
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(-1, -2);
        params.setMargins(0, 5, 0, 5);
        option.setLayoutParams(params);
        option.setPadding(10, 10, 10, 10);
        let state = false;
        option.setOnClickListener(Java.registerClass({
            name: "com.logger.OptionClick" + id,
            implements: [this.#classLoader.View_OnClickListener],
            methods: {
                onClick: (v) => {
                    state = !state;
                    v.setBackgroundColor(this.#classLoader.Color.parseColor(state ? this.#colorOn : this.#colorOff));
                    if (state) callbacks.on(); else callbacks.off();
                }
            }
        }).$new());
        this.#controlContainer.addView(option);
    }

    addButton(text, callback) {
        const button = this.#classLoader.TextView.$new(this.#activity);
        button.setText(this.#classLoader.String.$new(text));
        button.setBackgroundColor(this.#classLoader.Color.parseColor(this.#colorOff));
        button.setTextColor(this.#classLoader.Color.WHITE.value);
        button.setGravity(this.#classLoader.Gravity.CENTER.value);
        const params = this.#classLoader.LinearLayout_LayoutParams.$new(-1, -2);
        params.setMargins(0, 5, 0, 5);
        button.setLayoutParams(params);
        button.setPadding(10, 10, 10, 10);
        button.setOnClickListener(Java.registerClass({
            name: "com.logger.ButtonClick" + text.replace(/ /g, ""),
            implements: [this.#classLoader.View_OnClickListener],
            methods: { onClick: (v) => callback() }
        }).$new());
        this.#controlContainer.addView(button);
    }

    addLog(text) {
        Java.scheduleOnMainThread(() => {
            const logEntry = this.#classLoader.TextView.$new(this.#activity);
            logEntry.setText(this.#classLoader.String.$new(text));
            logEntry.setTextColor(this.#classLoader.Color.parseColor("#00FF00"));
            logEntry.setTypeface(this.#classLoader.Typeface.MONOSPACE);
            this.#logContainer.addView(logEntry, 0);
            if (this.#logContainer.getChildCount() > 50) {
                this.#logContainer.removeViewAt(50);
            }
        });
    }
    
    clearLog() { this.#logContainer.removeAllViews(); }
    start() { this.#activity.addContentView(this.rootView, this.rootView.getLayoutParams()); }
}


// --- LÓGICA DE ENGENHARIA REVERSA ---
const LIB_NAME = "libqplay.so";
const RVA_DKCH_POINTER = 0x26C3A4; 
const OFFSET_TO_ENTITY_LIST = 0x318; 
const OFFSET_COUNT = 0x8;   
const OFFSET_ARRAY_START = 0xC; 
const POINTER_SIZE = 4;

function readGlobalAddress(base) {
    const dkchAddress = base.add(RVA_DKCH_POINTER);
    return dkchAddress.readPointer(); 
}

function dumpEntityList() {
    let logLines = ["", "=== DUMP DE ENTIDADES ==="];
    
    try {
        const targetModule = Process.findModuleByName(LIB_NAME);
        if (!targetModule) {
            logLines.push(`[ERRO] Módulo ${LIB_NAME} não encontrado.`);
            return;
        }

        const entityManagerInstance = readGlobalAddress(targetModule.base);

        if (entityManagerInstance.isNull()) {
            logLines.push(`[ERRO] Instância Global (DKCH) não inicializada.`);
            return;
        }
        logLines.push(`[INFO] Gerenciador Base: ${entityManagerInstance}`);

        // Leitura 32-bit forçada (Corrige desalinhamento)
        const entityListObjectPtr = entityManagerInstance.add(OFFSET_TO_ENTITY_LIST);
        const entityListObjectU32 = entityListObjectPtr.readU32();
        const entityListObject = ptr(entityListObjectU32);

        if (entityListObject.isNull()) {
            logLines.push(`[ERRO] Ponteiro da Lista (+0x318) é NULL.`);
            return;
        }
        
        // Leitura de Count e Array Start
        const entityCount = entityListObject.add(OFFSET_COUNT).readInt(); 
        const entityArrayStartU32 = entityListObject.add(OFFSET_ARRAY_START).readU32();
        const entityArrayStart = ptr(entityArrayStartU32);

        logLines.push(`[INFO] Objeto Lista: ${entityListObject}`);
        logLines.push(`[TOTAL] Entidades Ativas: ${entityCount}`);
        
        if (entityCount > 0 && entityCount < 5000 && !entityArrayStart.isNull()) {
            logLines.push("--- Endereços de Objetos ---");
            for (let i = 0; i < Math.min(entityCount, 50); i++) {
                const entityPointerOffset = i * POINTER_SIZE;
                const entityObjectAddress = entityArrayStart.add(entityPointerOffset).readPointer();
                logLines.push(`[${i.toString().padStart(2, '0')}] ${entityObjectAddress}`);
            }
        } else if (entityCount > 5000) {
            logLines.push("[ERRO] Contagem irrealista. Estrutura de Count incorreta.");
        }

    } catch (e) {
        // Captura o access violation
        logLines.push(`[ERRO CRÍTICO] Falha na leitura de memória: ${e.message}`);
        logLines.push("-> Falha provável no desalinhamento do ponteiro.");
    } finally {
        logLines.push("==========================");
        logLines.forEach(line => menu.addLog(line));
    }
}


// --- EXECUÇÃO PRINCIPAL ---
setTimeout(() => {
    Java.perform(function () {
        try {
            const classLoader = getClassLoader();
            const mainActivity = getMainActivity(classLoader);
            
            menu = new Menu(classLoader, mainActivity, "Entity List Inspector", 350, "#B318122B"); 
            menu.setOptionColors("#B3443C68", "#B3393053");

            // Não precisamos mais do hook de timing, a leitura será por botão.
            
            menu.addButton("Limpar Log", () => { menu.clearLog(); });
            // ADICIONAMOS O BOTÃO DE AÇÃO PRINCIPAL
            menu.addButton("MOSTRAR LISTA DE ENTIDADES", dumpEntityList);

            menu.start();
            menu.addLog("[LOADED] Menu de Inspeção de Entidades Ativo.");

        } catch (error) { 
            console.error(`[!] Erro ao iniciar a UI/Frida: ${error.message}`); 
        }
    });

}, 5000); // 5 segundos de espera para o sistema Java carregar
