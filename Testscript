/**
 * Script de Hook: Entity List (Lista de Entidades)
 *
 * Objetivo: Detectar e listar todas as entidades (objetos, jogadores, etc.) do jogo
 * em um menu flutuante.
 */
(function() {
    // ========================================================================
    // VARIÁVEIS DO JOGO
    // ========================================================================
    
    // Supondo que 'MpGzgariDy' é o ponteiro global para o gerenciador de entidades (o "World" ou "Level").
    // O ponteiro 'activeplayer' está no escopo, mas usaremos a entidade principal.
    const get_entity_manager = Module.findExportByName("libqplay.so", "dkCHgaGRiF"); 
    if (!get_entity_manager) {
        console.error("ERRO: Export 'dkCHgaGRiF' (Gerenciador de Entidades) não encontrado. Script inativo.");
        return;
    }
    const activeplayer = get_entity_manager.readPointer();
    
    // Assumimos que a lista de entidades é uma estrutura em um offset do gerenciador.
    // É uma suposição comum, mas o OFFSET PODE MUDAR.
    // Exemplo: 0x140 ou 0x130 pode ser o ponteiro para o array/vector de entidades.
    // **Você pode precisar ajustar este OFFSET_ENTITY_VECTOR baseado na análise do binário.**
    const OFFSET_ENTITY_VECTOR = 0x140; 
    
    // Funções do Jogo (Apenas o necessário)
    const getlocaly = new NativeFunction(Module.findExportByName("libqplay.so", "_ZNK10W6NzgawMJy10qCgWga1ADREv"), "double", ["pointer"]);
    const getlocalx = new NativeFunction(Module.findExportByName("libqplay.so", "_ZNK10W6NzgawMJy10Qi2VgaCyrREv"), "double", ["pointer"]);
    
    // Função utilitária para ler TString (Inalterado)
    function readTString(str) { 
        if (!str.isNull() && parseInt(str) != 0) { 
            var pstr = str.readPointer(); 
            if (!pstr.isNull()) { 
                var strlen = pstr.readInt(); 
                if (strlen > 0 && strlen < 256) // Limite razoável para evitar crash em dados corrompidos
                    return ptr(parseInt(pstr) + 8).readCString(strlen); 
            } 
        } 
        return "N/A"; 
    }
    
    // Funções de Propriedades de Entidade (Apenas o necessário para lista)
    function getPlayerProperties(p) { 
        return {
            // Nota: O offset para nick (464) pode ser diferente para outras entidades
            "nick": readTString(p.add(464)), 
            "account": readTString(p.add(696)),
            "x": Memory.readDouble(p.add(0x238)), 
            "y": Memory.readDouble(p.add(0x240)), 
        }; 
    }
    
    // ========================================================================
    // LÓGICA DE DETECÇÃO DE ENTIDADES
    // ========================================================================

    // Função principal para listar entidades
    function listEntities(activePlayerPtr) {
        const entityList = [];
        
        // Ponteiro para o gerenciador principal
        const entity_manager = Memory.readPointer(activePlayerPtr);
        if (entity_manager.isNull()) {
            return entityList;
        }

        // Ponteiro para a estrutura do vetor (std::vector no C++ ou equivalente)
        const vector_ptr = entity_manager.add(OFFSET_ENTITY_VECTOR);
        
        // Leitura do ponteiro inicial e final do vetor (std::vector implementation)
        const start_ptr = vector_ptr.readPointer();
        const end_ptr = vector_ptr.add(8).readPointer(); 
        
        // Se a lista estiver vazia
        if (start_ptr.equals(end_ptr)) {
            return entityList;
        }

        // Tamanho do ponteiro (4 bytes em 32-bit, 8 bytes em 64-bit)
        const PTR_SIZE = Process.pointerSize; 

        let current_ptr = start_ptr;
        let count = 0;

        // Itera pelo vetor de ponteiros
        while (current_ptr.compare(end_ptr) < 0) {
            const entity_ptr = current_ptr.readPointer();
            
            if (!entity_ptr.isNull() && entity_ptr.compare(ptr(1000)) > 0) { // Ignora ponteiros muito baixos
                const props = getPlayerProperties(entity_ptr);
                
                // Calculando a distância (apenas para exibição)
                const localX = getlocalx(activePlayerPtr);
                const localY = getlocaly(activePlayerPtr);
                const dx = props.x - localX;
                const dy = props.y - localY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                let name = `0x${entity_ptr.toString(16)}`;
                if (props.nick && props.nick !== "N/A" && props.nick.trim().length > 0) {
                    name = props.nick;
                } else if (props.account && props.account !== "N/A" && props.account.trim().length > 0) {
                    name = props.account;
                }

                entityList.push({
                    name: name,
                    ptr: entity_ptr.toString(16),
                    pos: `(${props.x.toFixed(1)}, ${props.y.toFixed(1)})`,
                    dist: distance.toFixed(1),
                    isPlayer: (props.nick && props.nick !== "N/A") || (props.account && props.account !== "N/A") // Heurística
                });
                count++;
            }

            // Move para o próximo ponteiro na lista
            current_ptr = current_ptr.add(PTR_SIZE);
            if (count > 200) break; // Limite de segurança
        }

        return entityList;
    }


    // ========================================================================
    // UTILS e UI (Mínimo Necessário)
    // ========================================================================
    
    // Funções utilitárias (mínimo necessário, adaptado do original)
    function getClassLoader() {
        return {
            Gravity: Java.use("android.view.Gravity"),
            TextView: Java.use("android.widget.TextView"),
            LinearLayout: Java.use("android.widget.LinearLayout"),
            LinearLayout_LayoutParams: Java.use("android.widget.LinearLayout$LayoutParams"),
            Color: Java.use("android.graphics.Color"),
            ActivityThread: Java.use("android.app.ActivityThread"),
            String: Java.use("java.lang.String"),
            View: Java.use("android.view.View"),
            ScrollView: Java.use("android.widget.ScrollView") // Novo componente para lista rolável
        };
    }

    function pixelDensityToPixels(context, dp) {
        const density = context.getResources().getDisplayMetrics().density.value;
        return parseInt(dp * density);
    }

    function getMainActivity(classLoader) {
        const activityThread = classLoader.ActivityThread.sCurrentActivityThread.value;
        const mActivities = activityThread.mActivities.value;
        const activityClientRecord = Java.cast(mActivities.valueAt(0), Java.use("android.app.ActivityThread$ActivityClientRecord"));
        return activityClientRecord.activity.value;
    }
    
    // ========================================================================
    // CRIAÇÃO DA INTERFACE GRÁFICA (UI)
    // ========================================================================

    Java.perform(function () {
        // Delay para garantir que a Activity está pronta
        Java.scheduleOnMainThread(function () {
            const classLoader = getClassLoader();
            const mainActivity = getMainActivity(classLoader);
            const Gravity = classLoader.Gravity;
            const View = classLoader.View;

            const COLOR_BG = classLoader.Color.parseColor("#C0000000"); // Preto semi-transparente
            const COLOR_PLAYER = classLoader.Color.parseColor("#FFFFA500"); // Laranja para jogadores
            const COLOR_OTHER = classLoader.Color.WHITE.value;
            const PADDING = pixelDensityToPixels(mainActivity, 4);
            const MARGIN = pixelDensityToPixels(mainActivity, 2);
            const WIDTH_DP = 250; // Largura fixa para o menu
            const HEIGHT_DP = 300; // Altura fixa para o menu

            const WIDTH_PX = pixelDensityToPixels(mainActivity, WIDTH_DP);
            const HEIGHT_PX = pixelDensityToPixels(mainActivity, HEIGHT_DP);

            // ----------------------------------------------------------------
            // 1. Container da Lista (Scrollable)
            // ----------------------------------------------------------------
            const entityListContainer = classLoader.LinearLayout.$new(mainActivity);
            entityListContainer.setOrientation(classLoader.LinearLayout.VERTICAL.value);
            entityListContainer.setPadding(PADDING, PADDING, PADDING, PADDING);
            
            // ----------------------------------------------------------------
            // 2. ScrollView (Permite que a lista seja maior que a tela e role)
            // ----------------------------------------------------------------
            const scrollView = classLoader.ScrollView.$new(mainActivity);
            scrollView.setBackgroundColor(COLOR_BG);
            scrollView.addView(entityListContainer);
            
            const scrollParams = classLoader.LinearLayout_LayoutParams.$new(WIDTH_PX, HEIGHT_PX);
            // Posição: Canto superior direito
            const mainLayoutParams = classLoader.LinearLayout_LayoutParams.$new(-1, -1);
            
            // ----------------------------------------------------------------
            // 3. Layout Principal (Top Right)
            // ----------------------------------------------------------------
            const mainLayout = classLoader.LinearLayout.$new(mainActivity);
            mainLayout.setLayoutParams(mainLayoutParams);
            mainLayout.setGravity(Gravity.TOP.value | Gravity.RIGHT.value);
            
            // Layout Wrapper para dar margem
            const wrapperLayout = classLoader.LinearLayout.$new(mainActivity);
            const wrapperParams = classLoader.LinearLayout_LayoutParams.$new(WIDTH_PX, HEIGHT_PX);
            wrapperParams.setMargins(MARGIN, MARGIN, MARGIN, MARGIN);
            wrapperLayout.setLayoutParams(wrapperParams);
            wrapperLayout.addView(scrollView);
            
            mainLayout.addView(wrapperLayout);
            mainActivity.addContentView(mainLayout, mainLayoutParams);

            // ----------------------------------------------------------------
            // Lógica de Atualização da Lista
            // ----------------------------------------------------------------
            
            // Array para manter as referências dos TextViews
            let entityTextViews = [];

            const updateEntityListUI = () => {
                const entities = listEntities(activeplayer);
                
                // 1. Remove views antigas se houver mais do que o necessário
                while (entityTextViews.length > entities.length) {
                    const viewToRemove = entityTextViews.pop();
                    entityListContainer.removeView(viewToRemove);
                }

                // 2. Atualiza ou cria TextViews
                for (let i = 0; i < entities.length; i++) {
                    const entity = entities[i];
                    let textView;
                    
                    const entityText = `${entity.name} [Dist: ${entity.dist} / Ptr: 0x${entity.ptr}]`;

                    if (i < entityTextViews.length) {
                        // Atualiza TextView existente
                        textView = entityTextViews[i];
                        textView.setText(classLoader.String.$new(entityText));
                    } else {
                        // Cria novo TextView
                        textView = classLoader.TextView.$new(mainActivity);
                        textView.setText(classLoader.String.$new(entityText));
                        textView.setPadding(PADDING, 0, PADDING, 0); // Pequeno padding
                        
                        const textParams = classLoader.LinearLayout_LayoutParams.$new(-1, -2);
                        textView.setLayoutParams(textParams);
                        
                        entityListContainer.addView(textView);
                        entityTextViews.push(textView);
                    }
                    
                    // Colore o texto: Laranja para 'Jogadores' (pela heurística), Branco para outros
                    textView.setTextColor(entity.isPlayer ? COLOR_PLAYER : COLOR_OTHER);
                }
                
                // Se a lista estiver vazia
                if (entities.length === 0) {
                    const noEntityText = "Nenhuma entidade detectada (Verifique o OFFSET_ENTITY_VECTOR!).";
                    if (entityTextViews.length === 0) {
                         const textView = classLoader.TextView.$new(mainActivity);
                         textView.setText(classLoader.String.$new(noEntityText));
                         textView.setTextColor(COLOR_OTHER);
                         entityListContainer.addView(textView);
                         entityTextViews.push(textView);
                    } else {
                        entityTextViews[0].setText(classLoader.String.$new(noEntityText));
                        entityTextViews[0].setTextColor(COLOR_OTHER);
                    }
                }
            };
            
            // Chama a função de atualização a cada 500ms
            setInterval(updateEntityListUI, 500);

            console.log("[ENTITY LIST] Menu de Entidades Carregado.");
        });
    });
    
})();
